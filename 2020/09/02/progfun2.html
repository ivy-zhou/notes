<!DOCTYPE html><html lang="en">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>Functional Program Design in Scala - Sentences</title>

<meta name="description" content="Functional Program Design in ScalaWeek 1Recap: Functions and Pattern Matching// We'd represent JSONs in Scala using case classesabstract class JSONcase class...">
<link rel="canonical" href="notes/2020/09/02/progfun2.html"><link rel="alternate" type="application/rss+xml" title="Sentences" href="notes/feed.xml"><!-- start favicons snippet, use https://realfavicongenerator.net/ --><link rel="apple-touch-icon" sizes="180x180" href="notes/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="notes/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="notes/assets/favicon-16x16.png"><link rel="manifest" href="notes/assets/site.webmanifest"><link rel="mask-icon" href="notes/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="notes/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="notes/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicons snippet --><link rel="stylesheet" href="notes/assets/css/main.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" ><!-- start custom head snippets -->

<!-- end custom head snippets -->
<script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.isFormElement = function(node) {
    var tagName = node.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i;
      loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cbs[i]();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();
(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();
(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();
</script><script>
  (function() {
    var TEXT_VARIABLES = {
      version: '2.2.6',
      sources: {
        font_awesome: 'https://use.fontawesome.com/releases/v5.0.13/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        valine: 'https://unpkg.com/valine/dist/Valine.min.js',
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3'
        }
      },
      paths: {
        search_js: 'notes/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script>
</head>
  <body>
    <div class="root" data-is-touch="false">
      <div class="layout--page js-page-root"><div class="page__main js-page-main page__viewport has-aside cell cell--auto">

      <div class="page__main-inner"><div class="page__header d-print-none"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="24px" height="24px" viewBox="0 0 24 24">
<style type="text/css">
	.st0{fill:#515151;}
</style>
<path class="st0" d="M1.7,22.3c5.7-5.7,11.3-5.7,17,0c3.3-3.3,3.5-5.3,0.8-6c2.7,0.7,3.5-1.1,2.3-5.6s-3.3-5.2-6.3-2.1
	c3-3,2.3-5.2-2.1-6.3S7,1.8,7.7,4.6C7,1.8,5,2.1,1.7,5.3C7.3,11,7.3,16.7,1.7,22.3"/>
</svg>
<a title="A loosely organized collection of notes and thoughts
" href="notes/">Sentences</a></div><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></div><nav class="navigation">
        <ul><li class="navigation__item"><a href="notes/archive.html">Archive</a></li><li class="navigation__item"><a href="notes/about.html">About</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li></ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class ="main"><div class="grid grid--reverse">

              <div class="col-aside d-print-none js-col-aside"><aside class="page__aside js-page-aside"><div class="toc-aside js-toc-root"></div>
</aside></div>

              <div class="col-main cell cell--auto"><!-- start custom main top snippet -->

<!-- end custom main top snippet -->
<article itemscope itemtype="http://schema.org/Article"><div class="article__header"><header><h1>Functional Program Design in Scala</h1></header><span class="split-space">&nbsp;</span>
          <a class="edit-on-github"
            title="Edit on Github"
            href="https://github.com/ivy-zhou/notes/tree/master/_posts/2020-09-02-progfun2/2020-09-02-progfun2.md">
            <i class="far fa-edit"></i></a></div><meta itemprop="headline" content="Functional Program Design in Scala"><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="notes/archive.html?tag=coursera">coursera</a>
            </li><li>
              <a class="button button--secondary button--pill button--sm"
                href="notes/archive.html?tag=notes">notes</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Sep 02, 2020</span>
            </li></ul></div><meta itemprop="author" content="Ivy Zhou"/><meta itemprop="datePublished" content="2020-09-02T00:00:00+00:00">
    <meta itemprop="keywords" content="coursera,notes"><div class="js-article-content"><div class="layout--article"><!-- start custom article top snippet -->

<!-- end custom article top snippet -->
<div class="article__content" itemprop="articleBody"><p><a href="https://www.coursera.org/learn/progfun2">Functional Program Design in Scala</a></p>

<h1 id="week-1">Week 1</h1>

<h3 id="recap-functions-and-pattern-matching">Recap: Functions and Pattern Matching</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We'd represent JSONs in Scala using case classes</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">JSON</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JSeq</span><span class="o">(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">JSON</span><span class="o">]</span> <span class="k">extends</span> <span class="nc">JSON</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JObj</span><span class="o">(</span><span class="n">bindings</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">JSON</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">JSON</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JNum</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JSON</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JStr</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JSON</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JBool</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JSON</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">JNull</span>

<span class="k">type</span> <span class="kt">JBinding</span> <span class="o">=</span> <span class="o">[</span><span class="kt">String</span>, <span class="kt">JSON</span><span class="o">]</span>

<span class="k">val</span> <span class="nv">data</span> <span class="k">=</span> <span class="nc">JObj</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span>
	<span class="s">"firstName"</span> <span class="o">-&gt;</span> <span class="nc">JStr</span><span class="o">(</span><span class="s">"John"</span><span class="o">),</span>
	<span class="s">"address"</span> <span class="o">-&gt;</span> <span class="nc">JObj</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span>
		<span class="s">"streetAdrress"</span> <span class="o">-&gt;</span> <span class="nc">JStr</span><span class="o">(</span><span class="s">"21 2nd Street"</span><span class="o">),</span>
		<span class="s">"state"</span> <span class="o">-&gt;</span> <span class="nc">JStr</span><span class="o">(</span><span class="s">"NY"</span><span class="o">),</span>
		<span class="s">"postalCode"</span> <span class="o">-&gt;</span> <span class="nc">JNum</span><span class="o">(</span><span class="mi">10021</span><span class="o">)</span>
	<span class="o">)),</span>
	<span class="s">"phoneNumbers"</span> <span class="o">-&gt;</span> <span class="nc">JSeq</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span>
		<span class="nc">JStr</span><span class="o">(</span><span class="s">"212 555-1234"</span><span class="o">),</span> <span class="nc">JStr</span><span class="o">(</span><span class="s">"646 555-4567"</span><span class="o">)</span>
	<span class="o">))</span>
<span class="o">))</span>

<span class="c1">// To show a JSON, we'd also use pattern matching</span>
<span class="k">def</span> <span class="nf">show</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JSON</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">json</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">JSeq</span><span class="o">(</span><span class="n">elems</span><span class="o">)</span> <span class="k">=&gt;</span>
		<span class="s">"["</span> <span class="o">+</span> <span class="o">(</span><span class="n">elems</span> <span class="n">map</span> <span class="n">show</span> <span class="n">mkString</span> <span class="s">","</span><span class="o">)</span> <span class="o">+</span> <span class="s">"]"</span>
	<span class="k">case</span> <span class="nc">JObj</span><span class="o">(</span><span class="n">bindings</span><span class="o">)</span> <span class="k">=&gt;</span>
		<span class="k">val</span> <span class="nv">assocs</span> <span class="k">=</span> <span class="n">bindings</span> <span class="n">map</span> <span class="o">{</span>
			<span class="c1">// This case block is a function of type JBinding =&gt; String,</span>
			<span class="c1">// or, scala.Function1[JBinding, String], where Function1 is a trait</span>
			<span class="nf">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"\""</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s">"\": "</span> <span class="o">+</span> <span class="nf">show</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
		<span class="o">}</span>
		<span class="s">"{"</span> <span class="o">+</span> <span class="o">(</span><span class="n">assocs</span> <span class="n">mkString</span> <span class="s">","</span><span class="o">)</span> <span class="o">+</span> <span class="s">"}"</span>
	<span class="k">case</span> <span class="nc">JNum</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">num</span><span class="o">.</span><span class="py">toString</span>
	<span class="k">case</span> <span class="nc">JStr</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"\""</span> <span class="o">+</span> <span class="n">str</span> <span class="o">+</span> <span class="s">"\""</span>
	<span class="k">case</span> <span class="nc">JBool</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">toString</span>
	<span class="k">case</span> <span class="nc">JNull</span> <span class="k">=&gt;</span> <span class="s">"null"</span>
<span class="o">}</span>

<span class="c1">// We could rewrite the anonymous function in the case block as</span>
<span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-A</span>, <span class="kt">+R</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>
<span class="o">}</span>
<span class="k">new</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">JBinding</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">JBinding</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
		<span class="nf">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"\""</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s">"\": "</span> <span class="o">+</span> <span class="nf">show</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Functions are traits, so we can subclass functions in Scala</span>
<span class="c1">// maps are functions from keys to values</span>
<span class="k">trait</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Key</span>, <span class="kt">Value</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="nc">Key</span> <span class="k">=&gt;</span> <span class="nc">Value</span><span class="o">)</span> <span class="o">...</span>
<span class="c1">// sequences are functions from indices to elements</span>
<span class="k">trait</span> <span class="nc">Seq</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="nc">Elem</span><span class="o">)</span> <span class="o">...</span>

<span class="c1">// f is a function</span>
<span class="k">val</span> <span class="nv">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">String</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="s">"ping"</span> <span class="k">=&gt;</span> <span class="s">"pong"</span> <span class="o">}</span>
<span class="nf">f</span><span class="o">(</span><span class="s">"ping"</span><span class="o">)</span> <span class="c1">// pong</span>
<span class="nf">f</span><span class="o">(</span><span class="s">"abc"</span><span class="o">)</span> <span class="c1">// MatchError</span>

<span class="c1">// To guard against MatchErrors, we can use PartialFunctions</span>
<span class="k">val</span> <span class="nv">f</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="s">"ping"</span> <span class="k">=&gt;</span> <span class="s">"pong"</span> <span class="o">}</span>
<span class="nv">f</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="s">"ping"</span><span class="o">)</span> <span class="c1">// true</span>
<span class="nv">f</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">(</span><span class="s">"abc"</span><span class="o">)</span> <span class="c1">// false</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// As an exercise, let's look at the following function</span>
<span class="k">val</span> <span class="nv">f</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="s">"one"</span>
	<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span> <span class="s">"two"</span>
<span class="o">}</span>

<span class="nv">f</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">((</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">// true, since it returns "two"</span>

<span class="c1">// A variation</span>
<span class="k">val</span> <span class="nv">g</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="s">"one"</span>
	<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span> <span class="o">{</span>
		<span class="n">rest</span> <span class="k">match</span> <span class="o">{</span>
			<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="s">"two"</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="nv">f</span><span class="o">.</span><span class="py">isDefinedAt</span><span class="o">((</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">// true, even though you'd get a MatchError!</span>
<span class="c1">// because rest matches against the [2, 3]</span>
<span class="c1">// isDefinedAt only guarantees the outermost pattern matching</span>
</code></pre></div></div>

<h3 id="recap-collections">Recap: Collections</h3>

<p>All collections share the methods: <code class="language-plaintext highlighter-rouge">map, flatMap, filter, foldLeft, foldRight</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Let's see these methods on a List</span>
<span class="c1">// These are idealized, since they should actually be</span>
<span class="c1">// applicable to arbitrary collections and tail recursives</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">::</span> <span class="nv">xs</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
	<span class="o">}</span>

	<span class="c1">// f returns a List[U], which we must flatten to U</span>
	<span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="c1">// use the ++ concatenation operation instead of ::</span>
		<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">++</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
	<span class="o">}</span>

	<span class="k">def</span> <span class="nf">filter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="nf">p</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="nv">xs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="k">else</span> <span class="nv">xs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Recall for-expressions, which simplify applications of <code class="language-plaintext highlighter-rouge">flatMap</code>, <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>, etc.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Translate for into flatMaps/maps/filters</span>
<span class="k">for</span> <span class="o">{</span>
	<span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">n</span>
	<span class="n">j</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">i</span>
	<span class="k">if</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
<span class="o">===</span> <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">n</span><span class="o">)</span> <span class="nf">flatMap</span> <span class="o">(</span> <span class="n">i</span> <span class="k">=&gt;</span>
	<span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">i</span><span class="o">)</span> <span class="nf">withFilter</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">))</span> <span class="nf">map</span>
			<span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span>

<span class="c1">// Translate map, flatMap, filter into for</span>
<span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
	<span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="k">yield</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
	<span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">filter</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
	<span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span> <span class="k">if</span> <span class="nf">p</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">x</span>
</code></pre></div></div>

<p>The Scala compiler is automatically able to perform this conversion based on 3 rules:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">for (x &lt;- e1) yield e2</code> ⇒ <code class="language-plaintext highlighter-rouge">e1.map(x =&gt; e2)</code></li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">for (x &lt;- e1 if f; s) yield e2</code> ⇒ <code class="language-plaintext highlighter-rouge">for (x &lt;- e1.withFilter(x =&gt; f); s) yield e2</code></p>

    <p><code class="language-plaintext highlighter-rouge">withFilter</code> is a lazy implementation of <code class="language-plaintext highlighter-rouge">filter</code> that immediately create a new intermediate filtered list. Instead, on the next subsequent call to the list (i.e. in a <code class="language-plaintext highlighter-rouge">map</code>) it remembers that it should filter.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">for (x &lt;- e1; y &lt;- e2; s) yield e3</code> ⇒ <code class="language-plaintext highlighter-rouge">e1.flatMap(x =&gt; for (y &lt;- e2; s) yield e3)</code></li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The left-hand side of a generator may also be a pattern</span>
<span class="n">al</span> <span class="n">data</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">JSON</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">for</span> <span class="o">{</span>
	<span class="c1">// match JSeq(bindings) to data</span>
	<span class="c1">// an implicit filter that discards JSeq, JStr etc.</span>
	<span class="nc">JObj</span><span class="o">(</span><span class="n">bindings</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">data</span>
	<span class="c1">// pattern match bindings("phoneNumbers") to JSeq(phones)</span>
	<span class="nc">JSeq</span><span class="o">(</span><span class="n">phones</span><span class="o">)</span> <span class="k">=</span> <span class="nf">bindings</span><span class="o">(</span><span class="s">"phoneNumbers"</span><span class="o">)</span>
	<span class="nc">JObj</span><span class="o">(</span><span class="n">phone</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">phones</span>
	<span class="nc">JStr</span><span class="o">(</span><span class="n">digits</span><span class="o">)</span> <span class="k">=</span> <span class="nf">phone</span><span class="o">(</span><span class="s">"number"</span><span class="o">)</span>
	<span class="k">if</span> <span class="n">digits</span> <span class="n">startsWith</span> <span class="s">"212"</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="nf">bindings</span><span class="o">(</span><span class="s">"firstName"</span><span class="o">),</span> <span class="nf">bindings</span><span class="o">(</span><span class="s">"lastName"</span><span class="o">))</span>

<span class="c1">// If pat is a pattern with a single variable x,</span>
<span class="n">pat</span> <span class="k">&lt;-</span> <span class="n">expr</span>
<span class="o">===</span>
<span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr</span> <span class="n">withFilter</span> <span class="o">{</span>
	<span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="kc">true</span>
	<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span> <span class="n">map</span> <span class="o">{</span>
	<span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="n">x</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As an exercise, let’s translate the following expression:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
	<span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">2</span> <span class="n">to</span> <span class="n">N</span>
	<span class="n">y</span> <span class="k">&lt;-</span> <span class="mi">2</span> <span class="n">to</span> <span class="n">x</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="o">===</span>
<span class="o">(</span><span class="mi">2</span> <span class="n">to</span> <span class="n">N</span><span class="o">)</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span>
	<span class="o">(</span><span class="mi">2</span> <span class="n">to</span> <span class="n">x</span><span class="o">)</span> <span class="nf">withFilter</span> <span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span>
		<span class="n">x</span> <span class="o">%</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)))</span>
</code></pre></div></div>

<h3 id="queries-with-for">Queries with For</h3>

<p>Suppose we have a database of books, represented as a list of books.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">authors</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>

<span class="k">val</span> <span class="nv">books</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
	<span class="nc">Book</span><span class="o">(</span>
		<span class="n">title</span> <span class="k">=</span> <span class="s">"Structure and Interpretation of Computer Programs"</span><span class="o">,</span>
		<span class="n">authors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"Abelson, Harald"</span><span class="o">,</span> <span class="s">"Sussman, Gerald J."</span><span class="o">)),</span>
	<span class="nc">Book</span><span class="o">(</span>
		<span class="n">title</span> <span class="k">=</span> <span class="s">"Introduction to Functional Programming"</span><span class="o">,</span>
		<span class="n">authors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"Bird, Richard"</span><span class="o">,</span> <span class="s">"Wadler, Phil"</span><span class="o">)),</span>
	<span class="nc">Book</span><span class="o">(</span>
		<span class="n">title</span> <span class="k">=</span> <span class="s">"Effeective Java"</span><span class="o">,</span>
		<span class="n">authors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"Bloch, Joshua"</span><span class="o">)),</span>
	<span class="nc">Book</span><span class="o">(</span>
		<span class="n">title</span> <span class="k">=</span> <span class="s">"Java Puzzlers"</span><span class="o">,</span>
		<span class="n">authors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"Bloch, Joshua"</span><span class="o">,</span> <span class="s">"Gafter, Neal"</span><span class="o">)),</span>
	<span class="nc">Book</span><span class="o">(</span>
		<span class="n">title</span> <span class="k">=</span> <span class="s">"Programming in Scala"</span><span class="o">,</span>
		<span class="n">authors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"Odersky, Martin"</span><span class="o">,</span> <span class="s">"Spoon, Lex"</span><span class="o">,</span> <span class="s">"Venners, Bill"</span><span class="o">)),</span>
<span class="o">)</span>

<span class="c1">// Find the titles of books whose author's last name is Bird</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="nv">b</span><span class="o">.</span><span class="py">authors</span> <span class="k">if</span> <span class="n">a</span> <span class="n">startsWith</span> <span class="s">"Bird,"</span><span class="o">)</span>
<span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span>

<span class="c1">// Find all the books which have the word "Program" in the title</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span> <span class="n">indexOf</span> <span class="s">"Program"</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
<span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span>

<span class="c1">// Find the names of all authors who have written at least 2 books</span>
<span class="o">{</span>
	<span class="k">for</span> <span class="o">{</span>
		<span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span>
		<span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span>
		<span class="k">if</span> <span class="nv">b1</span><span class="o">.</span><span class="py">title</span> <span class="o">&lt;</span> <span class="nv">b2</span><span class="o">.</span><span class="py">title</span> <span class="c1">// prevent repeats like (B2, B1), (B1, B2)</span>
		<span class="n">a1</span> <span class="k">&lt;-</span> <span class="nv">b1</span><span class="o">.</span><span class="py">authors</span>
		<span class="n">a2</span> <span class="k">&lt;-</span> <span class="nv">b2</span><span class="o">.</span><span class="py">authors</span>
		<span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span>
	<span class="o">}</span> <span class="k">yield</span> <span class="n">a1</span>
<span class="o">}.</span><span class="py">distinct</span>

<span class="c1">// Suppose an author has published 3 books</span>
<span class="c1">// Then, we would have matches (B1, B2), (B1, B3), (B2, B3) in order</span>
<span class="c1">// So, the same author would be printed 3 times, so we need "distinct"</span>
<span class="c1">// Or, we can make the books list a Set to remove duplicates</span>
</code></pre></div></div>

<h3 id="translation-of-for">Translation of For</h3>

<p>Recall the Scala compiler for-expression conversion rules.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">for (x &lt;- e1) yield e2</code> ⇒ <code class="language-plaintext highlighter-rouge">e1.map(x =&gt; e2)</code></li>
  <li><code class="language-plaintext highlighter-rouge">for (x &lt;- e1 if f; s) yield e2</code> ⇒ <code class="language-plaintext highlighter-rouge">for (x &lt;- e1.withFilter(x =&gt; f); s) yield e2</code></li>
  <li><code class="language-plaintext highlighter-rouge">for (x &lt;- e1; y &lt;- e2; s) yield e3</code> ⇒ <code class="language-plaintext highlighter-rouge">e1.flatMap(x =&gt; for (y &lt;- e2; s) yield e3)</code></li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Find the titles of books whose author's last name is Bird</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="nv">b</span><span class="o">.</span><span class="py">authors</span> <span class="k">if</span> <span class="n">a</span> <span class="n">startsWith</span> <span class="s">"Bird,"</span><span class="o">)</span>
<span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span>
<span class="o">===</span> <span class="c1">// by rule 3</span>
<span class="nv">books</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span>
	<span class="nf">for</span> <span class="o">(</span><span class="n">a</span> <span class="k">&lt;-</span> <span class="nv">b</span><span class="o">.</span><span class="py">authors</span> <span class="k">if</span> <span class="n">a</span> <span class="n">startsWith</span> <span class="s">"Bird,"</span><span class="o">)</span> <span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span>
<span class="o">)</span>
<span class="o">===</span> <span class="c1">// by rule 2</span>
<span class="nv">books</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span>
	<span class="nf">for</span> <span class="o">(</span><span class="n">a</span> <span class="k">&lt;-</span> <span class="nv">b</span><span class="o">.</span><span class="py">authors</span> <span class="nf">withFilter</span> <span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">startsWith</span> <span class="s">"Bird,"</span><span class="o">))</span> <span class="k">yield</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span>
<span class="o">)</span>
<span class="o">===</span> <span class="c1">// by rule 1</span>
<span class="nv">books</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span>
	<span class="nv">b</span><span class="o">.</span><span class="py">authors</span> <span class="nf">withFilter</span> <span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="n">startsWith</span> <span class="s">"Bird,"</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">title</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>

<p>Notice for-expression translation is only dependent on the existence of the methods <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code>, and <code class="language-plaintext highlighter-rouge">withFilter</code>. This means that <code class="language-plaintext highlighter-rouge">for</code> expressions can be used with any types such as arrays, iterators, databases, XML data, optional values, parsers, etc which implement these methods, and not just lists.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An example from Slick, the Scala SQL library</span>
<span class="c1">// coffees, suppliers are tables</span>
<span class="k">val</span> <span class="nv">crossJoin</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">coffees</span> <span class="n">join</span> <span class="n">suppliers</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="nv">c</span><span class="o">.</span><span class="py">name</span><span class="o">,</span> <span class="nv">s</span><span class="o">.</span><span class="py">name</span><span class="o">)</span>
<span class="c1">// compiles to SQL (simplified):</span>
<span class="c1">//   select x2."COF_NAME", x3."SUP_NAME" from "COFFEES" x2</span>
<span class="c1">//     inner join "SUPPLIERS" x3</span>
</code></pre></div></div>

<h3 id="functional-random-generators">Functional Random Generators</h3>

<p>Let’s now use for-expressions to create a random value (booleans, strings, lists, pairs, sets etc.) generator.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
	<span class="n">self</span> <span class="k">=&gt;</span> <span class="c1">// alias for "this"</span>
	<span class="k">def</span> <span class="nf">generate</span><span class="k">:</span> <span class="kt">T</span>
	<span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
		<span class="c1">// Notice we have to use self in front of "generate" to avoid</span>
		<span class="c1">// recursive calls to this.generate</span>
		<span class="c1">// Or, we could use Generator.this.generate (works in Java too!)</span>
		<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nv">self</span><span class="o">.</span><span class="py">generate</span><span class="o">)</span>
	<span class="o">}</span>
	<span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">S</span><span class="o">])</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
		<span class="c1">// f(self.generate) gives a Generator[S], which we should generate again</span>
		<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="nv">self</span><span class="o">.</span><span class="py">generate</span><span class="o">).</span><span class="py">generate</span>
	<span class="o">}</span>
	<span class="k">def</span> <span class="nf">filter</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">p</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="n">generate</span><span class="o">)(</span><span class="nv">self</span><span class="o">.</span><span class="py">generate</span><span class="o">)</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">integers</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">val</span> <span class="nv">rand</span> <span class="k">=</span> <span class="k">new</span> <span class="nv">java</span><span class="o">.</span><span class="py">util</span><span class="o">.</span><span class="py">Random</span>
	<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="nv">rand</span><span class="o">.</span><span class="py">nextInt</span><span class="o">()</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">booleansBP</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="nv">integers</span><span class="o">.</span><span class="py">generate</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">pairsBP</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="o">(</span><span class="nv">integers</span><span class="o">.</span><span class="py">generate</span><span class="o">,</span> <span class="nv">integers</span><span class="o">.</span><span class="py">generate</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Since we wrote flatMap, map, and filter functions</span>
<span class="c1">// We can also define booleans and pairs like this and avoid boilerplate</span>
<span class="k">val</span> <span class="nv">booleans</span> <span class="k">=</span> <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">integers</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">===</span>
	<span class="n">integers</span> <span class="n">map</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">}</span>
<span class="o">===</span>
	<span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)(</span><span class="nv">integers</span><span class="o">.</span><span class="py">generate</span><span class="o">)</span>
	<span class="o">}</span>
<span class="o">===</span> <span class="c1">// the expression we started with</span>
	<span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="nv">integers</span><span class="o">.</span><span class="py">generate</span> <span class="o">&gt;</span> <span class="mi">0</span>
	<span class="o">}</span>

<span class="k">def</span> <span class="nf">pairs</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">u</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
	<span class="n">x</span> <span class="k">&lt;-</span> <span class="n">t</span><span class="o">,</span>
	<span class="n">y</span> <span class="k">&lt;-</span> <span class="n">u</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="o">===</span>
	<span class="n">t</span> <span class="n">flatMap</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="n">map</span> <span class="o">{</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">}</span> <span class="o">}</span>
<span class="o">===</span>
	<span class="n">t</span> <span class="n">flatMap</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nv">u</span><span class="o">.</span><span class="py">generate</span><span class="o">)</span> <span class="o">}}</span>
<span class="o">===</span>
	<span class="k">new</span> <span class="nc">Generator</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Generator</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="o">{</span>
			<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="o">(</span><span class="nv">t</span><span class="o">.</span><span class="py">generate</span><span class="o">,</span> <span class="nv">u</span><span class="o">.</span><span class="py">generate</span><span class="o">)</span>
		<span class="o">}).</span><span class="py">generate</span>
	<span class="o">}</span>
<span class="o">===</span> <span class="c1">// the expression we started with</span>
	<span class="k">new</span> <span class="nc">Generator</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="o">(</span><span class="nv">t</span><span class="o">.</span><span class="py">generate</span><span class="o">,</span> <span class="nv">u</span><span class="o">.</span><span class="py">generate</span><span class="o">)</span>
	<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Let's look at some examples of Generators</span>
<span class="k">def</span> <span class="nf">single</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">generate</span> <span class="k">=</span> <span class="n">x</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">choose</span><span class="o">(</span><span class="n">lo</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">hi</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
	<span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">integers</span><span class="o">)</span> <span class="k">yield</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">x</span> <span class="o">%</span> <span class="o">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="o">)</span>

<span class="c1">// T* means as many arguments as you want</span>
<span class="k">def</span> <span class="nf">oneOf</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
	<span class="nf">for</span> <span class="o">(</span><span class="n">idx</span> <span class="k">&lt;-</span> <span class="nf">choose</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span><span class="o">))</span> <span class="k">yield</span> <span class="nf">xs</span><span class="o">(</span><span class="n">idx</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">lists</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
	<span class="n">isEmpty</span> <span class="k">&lt;-</span> <span class="n">booleans</span> <span class="c1">// flip a coin to see if the list should be empty</span>
	<span class="n">list</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">emptyLists</span> <span class="k">else</span> <span class="n">nonEmptyLists</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">list</span>

<span class="k">def</span> <span class="nf">emptyLists</span> <span class="k">=</span> <span class="nf">single</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">nonEmptyList</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
	<span class="n">head</span> <span class="k">&lt;-</span> <span class="n">integers</span> <span class="c1">// pick a random head element</span>
	<span class="n">tail</span> <span class="k">&lt;-</span> <span class="n">lists</span> <span class="c1">// pick a random list for the rest of the list</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">head</span> <span class="o">::</span> <span class="n">tail</span>
</code></pre></div></div>

<p>As an exercise, let’s now implement a generator that creates random <code class="language-plaintext highlighter-rouge">Tree</code> objects.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Tree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Inner</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>

<span class="k">def</span> <span class="nf">trees</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">Tree</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
	<span class="n">isLeaf</span> <span class="k">&lt;-</span> <span class="n">booleans</span> <span class="c1">// flip a coin to see if this is a leaf or an inner node</span>
	<span class="n">tree</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="n">isLeaf</span><span class="o">)</span> <span class="n">leafs</span> <span class="k">else</span> <span class="n">inners</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">tree</span>

<span class="k">def</span> <span class="nf">leafs</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
	<span class="n">x</span> <span class="k">&lt;-</span> <span class="n">integers</span>
<span class="o">}</span> <span class="k">yield</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">inners</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
	<span class="n">l</span> <span class="k">&lt;-</span> <span class="n">trees</span>
	<span class="n">r</span> <span class="k">&lt;-</span> <span class="n">trees</span>
<span class="o">}</span> <span class="k">yield</span> <span class="nc">Inner</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</code></pre></div></div>

<p>One important application of random value generation is generating random test inputs.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">numTimes</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100</span><span class="o">)</span>
	<span class="c1">// test returns true if passed, false if failed</span>
	<span class="o">(</span><span class="n">test</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
	<span class="nf">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">numTimes</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">val</span> <span class="nv">value</span> <span class="k">=</span> <span class="nv">g</span><span class="o">.</span><span class="py">generate</span>
		<span class="nf">assert</span><span class="o">(</span><span class="nf">test</span><span class="o">(</span><span class="n">value</span><span class="o">),</span> <span class="s">"test failed for "</span> <span class="o">+</span> <span class="n">value</span><span class="o">)</span>
	<span class="o">}</span>
	<span class="nf">println</span><span class="o">(</span><span class="s">"passed "</span> <span class="o">+</span> <span class="n">numTimes</span> <span class="o">+</span> <span class="s">" tests"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Example usage</span>
<span class="nf">test</span><span class="o">(</span><span class="nf">pairs</span><span class="o">(</span><span class="n">lists</span><span class="o">,</span> <span class="n">lists</span><span class="o">))</span> <span class="o">{</span>
	<span class="nf">case</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">).</span><span class="py">length</span> <span class="o">&gt;</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span>
<span class="o">}</span>
<span class="c1">// test fails because ys is sometimes empty</span>
</code></pre></div></div>

<p>Using ScalaCheck, we can write <em>properties</em> which are assumed to hold instead of tests.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// l1 and l2 are automatically generated by ScalaCheck</span>
<span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">l1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">l2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=&gt;</span>
	<span class="nv">l1</span><span class="o">.</span><span class="py">size</span> <span class="o">+</span> <span class="nv">l2</span><span class="o">.</span><span class="py">size</span> <span class="o">==</span> <span class="o">(</span><span class="n">l1</span> <span class="o">++</span> <span class="n">l2</span><span class="o">).</span><span class="py">size</span>
<span class="o">}</span>
<span class="c1">// ScalaCheck will try to return the smallest possible counterexample</span>
</code></pre></div></div>

<h3 id="monads">Monads</h3>

<p>monad ⇒ a parametric type <code class="language-plaintext highlighter-rouge">M[T]</code> with two operations, <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">unit</code></p>

<p>Monads implementing <code class="language-plaintext highlighter-rouge">withFilter</code> are called “monads with zero”.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">M</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">unit</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</code></pre></div></div>

<p>We have seen some monads already:</p>

<ul>
  <li>List is a monad with <code class="language-plaintext highlighter-rouge">unit(x) = List(x)</code></li>
  <li>Set is a monad with <code class="language-plaintext highlighter-rouge">unit(x) = Set(x)</code></li>
  <li>Option is a monad with <code class="language-plaintext highlighter-rouge">unit(x) = Some(x)</code></li>
  <li>Generator is a monad with <code class="language-plaintext highlighter-rouge">unit(x) = single(x)</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">map</code> can be defined for every monad as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Scala doesn't have a global unit function, so map is a primitive</span>
<span class="c1">// function defined on every monad</span>
<span class="n">m</span> <span class="n">map</span> <span class="n">f</span> <span class="o">===</span> <span class="n">m</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">unit</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
				<span class="o">===</span> <span class="n">m</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">f</span> <span class="n">andThen</span> <span class="n">unit</span><span class="o">)</span>
</code></pre></div></div>

<p>Monads satisfy three laws:</p>

<ol>
  <li>
    <p>Associativity</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">m</span> <span class="n">flatMap</span> <span class="n">f</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">g</span> <span class="o">===</span> <span class="n">m</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">g</span><span class="o">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Left unit</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">unit</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">f</span> <span class="o">===</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Right unit</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span> <span class="n">flatMap</span> <span class="n">unit</span> <span class="o">===</span> <span class="n">m</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>Let’s check the monad laws for Option.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Left unit law</span>
<span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">f</span>
<span class="o">===</span>
	<span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
	<span class="o">}</span>
<span class="o">===</span>
	<span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// Some(x) matches Some(x)</span>

<span class="c1">// Right unit law</span>
<span class="n">opt</span> <span class="n">flatMap</span> <span class="nc">Some</span>
<span class="o">===</span>
	<span class="n">opt</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
	<span class="o">}</span>
<span class="o">===</span>
	<span class="n">opt</span> <span class="c1">// since in each case, we just return what we started with</span>

<span class="c1">// Associative law</span>
<span class="o">(</span><span class="n">opt</span> <span class="n">flatMap</span> <span class="n">f</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">g</span>
<span class="o">===</span>
	<span class="o">(</span><span class="n">opt</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span> <span class="o">})</span>
		<span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">g</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span> <span class="o">}</span>
<span class="o">===</span> <span class="c1">// move the second match _into_ the first one</span>
	<span class="n">opt</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span>
			<span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">g</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span> <span class="o">}</span>
		<span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
			<span class="nc">None</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">g</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span> <span class="o">}</span>
	<span class="o">}</span>
<span class="o">===</span> <span class="c1">// simplify</span>
	<span class="n">opt</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">g</span> <span class="c1">// expansion in reverse</span>
		<span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
	<span class="o">}</span>
<span class="o">===</span>
	<span class="n">opt</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">g</span><span class="o">)</span>

<span class="c1">// So, Option is a Monad</span>
</code></pre></div></div>

<p>Monad laws allow us to formally justify certain rewritings.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Associativity</span>
<span class="nf">for</span> <span class="o">(</span>
	<span class="n">y</span> <span class="k">&lt;-</span> <span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">m</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">y</span>
	<span class="n">z</span> <span class="k">&lt;-</span> <span class="nf">g</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
<span class="o">)</span> <span class="k">yield</span> <span class="n">z</span>
<span class="o">===</span>
<span class="nf">for</span> <span class="o">(</span>
	<span class="n">x</span> <span class="k">&lt;-</span> <span class="n">m</span>
	<span class="n">y</span> <span class="k">&lt;-</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
	<span class="n">z</span> <span class="k">&lt;-</span> <span class="nf">g</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
<span class="o">)</span> <span class="k">yield</span> <span class="n">z</span>

<span class="c1">// Right unit</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">m</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">===</span> <span class="n">m</span>
</code></pre></div></div>

<p>Let’s now look at type <code class="language-plaintext highlighter-rouge">Try</code>, used to pass results of computations that can fail with an exception.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Try</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span>
<span class="c1">// Like Option, except the Success case has a value and</span>
<span class="c1">// the Failure case has an exception</span>
<span class="c1">// Success doesn't really mean Success, more like Trial</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Success</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Exception</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Try</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>

<span class="k">class</span> <span class="nc">Try</span> <span class="o">{</span>
	<span class="c1">// expr is passed by name so that it's not evaluated before Success(expr)</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">expr</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
		<span class="k">try</span> <span class="nc">Success</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span>
		<span class="k">catch</span> <span class="o">{</span>
			<span class="c1">// Doesn't make sense to export fatal exceptions</span>
			<span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
		<span class="o">}</span>

	<span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Try</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">try</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">catch</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="o">}</span>
		<span class="k">case</span> <span class="n">fail</span><span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span> <span class="n">fail</span>
	<span class="o">}</span>

	<span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Try</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
		<span class="k">case</span> <span class="n">fail</span><span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span> <span class="n">fail</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">{</span>
	<span class="n">x</span> <span class="k">&lt;-</span> <span class="n">computeX</span>
	<span class="n">y</span> <span class="k">&lt;-</span> <span class="n">computeY</span>
<span class="o">}</span> <span class="k">yield</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="c1">// if computeX and computeY succeed, returns Success(f(x, y))</span>
<span class="c1">// if either fails, returns Failure(ex) of the first exception</span>

<span class="c1">// For a Try value t</span>
<span class="n">t</span> <span class="n">map</span> <span class="n">f</span> <span class="o">===</span> <span class="n">t</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nc">Try</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
				<span class="o">===</span> <span class="n">t</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">f</span> <span class="n">andThen</span> <span class="nc">Try</span><span class="o">)</span>
</code></pre></div></div>

<p>As an exercise, let’s try to prove that <code class="language-plaintext highlighter-rouge">Try</code> is a monad with unit of <code class="language-plaintext highlighter-rouge">Try</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Left unit fails</span>
<span class="nc">Try</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">f</span>
<span class="o">===</span>
<span class="nc">Try</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">try</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">catch</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="o">}</span>
	<span class="k">case</span> <span class="n">fail</span><span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span> <span class="n">fail</span>
<span class="o">}</span>
<span class="c1">// this is not f(expr), since it can raise an exception from f or expr</span>
</code></pre></div></div>

<h1 id="week-2">Week 2</h1>

<h2 id="structural-induction-on-trees">Structural Induction on Trees</h2>

<p>To prove a property P(1) for all trees t:</p>

<ol>
  <li>Show that P(1) holds for all leaves 1 of a tree</li>
  <li>For each internal node t with subtrees $s_1, \dots, s_n$, show that $P(s_1) \land \dots \land P(s_n)$ implies P(t).</li>
</ol>

<p>Recall the implementation of <code class="language-plaintext highlighter-rouge">IntSet</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">IntSet</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">incl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span>
	<span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">union</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">IntSet</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
	<span class="k">def</span> <span class="nf">incl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span> <span class="o">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">union</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">left</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IntSet</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">elem</span><span class="o">)</span> <span class="n">left</span> <span class="n">contains</span> <span class="n">x</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">elem</span><span class="o">)</span> <span class="n">right</span> <span class="n">contains</span> <span class="n">x</span>
		<span class="k">else</span> <span class="kc">true</span>

	<span class="k">def</span> <span class="nf">incl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span> <span class="o">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">elem</span><span class="o">)</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">left</span> <span class="n">incl</span> <span class="n">x</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">elem</span><span class="o">)</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span>
		<span class="k">else</span> <span class="k">this</span>

	<span class="k">def</span> <span class="nf">union</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="nf">union</span> <span class="o">(</span><span class="n">r</span> <span class="n">union</span> <span class="n">other</span><span class="o">))</span> <span class="n">incl</span> <span class="n">x</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s prove this implementation’s correctness by proving the following 3 laws, which completely characterize the data structure:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Empty contains x === false</code></p>

    <p>Proven according to the definition of <code class="language-plaintext highlighter-rouge">contains</code> in <code class="language-plaintext highlighter-rouge">Empty</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">(s incl x) contains x === true</code></p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Base case: Empty</span>
<span class="o">(</span><span class="nc">Empty</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span> <span class="c1">// by Empty.incl</span>
<span class="k">=</span> <span class="kc">true</span> <span class="c1">// by NonEmpty.contains</span>

<span class="c1">// Induction step: NonEmpty(z, l, r)</span>

<span class="c1">// Case 1: z = x</span>
<span class="o">(</span><span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="kc">true</span>

<span class="c1">// Case 2: z &lt; x</span>
<span class="o">(</span><span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="o">(</span><span class="n">r</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="kc">true</span> <span class="c1">// by induction hypothesis, since for all subtrees, IH holds</span>

<span class="c1">// Case 3: z &gt; x</span>
<span class="o">(</span><span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span> <span class="n">incl</span> <span class="n">x</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="o">(</span><span class="n">l</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="kc">true</span> <span class="c1">// by induction hypothesis, since for all subtrees, IH holds</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">(s incl y) contains x === s contains x if x != y</code></p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Assume that y &lt; x. The dual case will be completely analogous.</span>

<span class="c1">// Base case: Empty</span>
<span class="o">(</span><span class="nc">Empty</span> <span class="n">incl</span> <span class="n">y</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">Empty</span> <span class="n">contains</span> <span class="n">x</span>

<span class="c1">// Induction step: NonEmpty(x, l, r)</span>
<span class="c1">// Case 1: z = x</span>
<span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">incl</span> <span class="n">y</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span> <span class="n">incl</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="kc">true</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>

<span class="c1">// Case 2: z = y</span>
<span class="nc">NonEmpty</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">incl</span> <span class="n">y</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>

<span class="c1">// Case 3: z &lt; y &lt; x</span>
<span class="o">(</span><span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">incl</span> <span class="n">y</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span> <span class="n">incl</span> <span class="n">y</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="o">(</span><span class="n">r</span> <span class="n">incl</span> <span class="n">y</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="n">r</span> <span class="n">contains</span> <span class="n">x</span> <span class="c1">// by induction hypothesis</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>

<span class="c1">// Case 4: y &lt; z &lt; x</span>
<span class="o">(</span><span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">incl</span> <span class="n">y</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span> <span class="n">incl</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="n">r</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>

<span class="c1">// Case 5: y &lt; x &lt; x</span>
<span class="o">(</span><span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">incl</span> <span class="n">y</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span> <span class="n">incl</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="o">(</span><span class="n">l</span> <span class="n">incl</span> <span class="n">y</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="n">l</span> <span class="n">contains</span> <span class="n">x</span> <span class="c1">// by induction hypothesis</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>As an exercise, let’s now look at the correctness of union, which is translated into the law <code class="language-plaintext highlighter-rouge">(xs union ys) contains x = xs contains x || ys contains x</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Base case: Empty</span>
<span class="o">(</span><span class="nc">Empty</span> <span class="n">union</span> <span class="n">ys</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="n">ys</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="n">ys</span> <span class="n">contains</span> <span class="n">x</span> <span class="o">||</span> <span class="kc">false</span>
<span class="k">=</span> <span class="n">ys</span> <span class="n">contains</span> <span class="n">x</span> <span class="o">||</span> <span class="nc">Empty</span> <span class="n">contains</span> <span class="n">x</span>

<span class="c1">// Induction step: NonEmpty(z, l, r)</span>

<span class="c1">// Case 1: z = x</span>
<span class="o">((</span><span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">union</span> <span class="n">ys</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="o">((</span><span class="n">l</span> <span class="nf">union</span> <span class="o">(</span><span class="n">r</span> <span class="n">union</span> <span class="n">ys</span><span class="o">))</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="kc">true</span> <span class="c1">// by (s incl x) contains x === true</span>
<span class="k">=</span> <span class="kc">true</span> <span class="o">||</span> <span class="n">ys</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="o">((</span><span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span><span class="o">)</span> <span class="o">||</span> <span class="n">ys</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span> <span class="o">||</span> <span class="n">ys</span> <span class="n">contains</span> <span class="n">x</span>

<span class="c1">// Case 2: z &lt; x</span>
<span class="o">((</span><span class="nc">NonEmpty</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="n">union</span> <span class="n">ys</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span> <span class="o">((</span><span class="n">l</span> <span class="nf">union</span> <span class="o">(</span><span class="n">r</span> <span class="n">union</span> <span class="n">ys</span><span class="o">))</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span> <span class="n">contains</span> <span class="n">x</span>
<span class="k">=</span>
</code></pre></div></div>

<h2 id="streams">Streams</h2>

<p>Suppose we wanted to find the second prime number between 1000 and 10000.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We could write</span>
<span class="o">((</span><span class="mi">1000</span> <span class="n">to</span> <span class="mi">10000</span><span class="o">)</span> <span class="n">filter</span> <span class="n">isPrime</span><span class="o">)(</span><span class="mi">1</span><span class="o">)</span>

<span class="c1">// Or</span>
<span class="k">def</span> <span class="nf">secondPrime</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">to:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nf">nthPrime</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">nthPrimt</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">from</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"no prime"</span><span class="o">)</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">isPrime</span><span class="o">(</span><span class="n">from</span><span class="o">))</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="n">from</span> <span class="k">else</span> <span class="nf">nthPrime</span><span class="o">(</span><span class="n">from</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
		<span class="k">else</span> <span class="nf">nthPrime</span><span class="o">(</span><span class="n">from</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div></div>

<p>The first implementation is much cleaner, but much slower, since it has to construct all prime numbers between 1000 and 10000 in a list. We can make the first implementation more efficient using a <em>stream</em>.</p>

<p>stream ⇒ list where tail is evaluated only on demand</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Streams are defined from Stream.empty and a constructor Stream.cons</span>
<span class="k">val</span> <span class="nv">xs</span> <span class="k">=</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">cons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">cons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">empty</span><span class="o">))</span>
<span class="c1">// Or use factory construction method</span>
	<span class="o">===</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="c1">// Or, turn a collection into a stream</span>
	<span class="o">===</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">2</span><span class="o">).</span><span class="py">toStream</span>
</code></pre></div></div>

<p>Let’s write a function that returns a function that returns <code class="language-plaintext highlighter-rouge">(lo until hi).toStream</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This is how we would create a list like (1 to 40)</span>
<span class="k">def</span> <span class="nf">listRange</span><span class="o">(</span><span class="n">lo</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">hi</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">hi</span><span class="o">)</span> <span class="nc">Nil</span>
	<span class="k">else</span> <span class="n">lo</span> <span class="o">::</span> <span class="nf">listRange</span><span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">)</span>

<span class="c1">// The code for streams is very similar, but Stream.cons is a lazy</span>
<span class="c1">// constructor, unlike ::</span>
<span class="k">def</span> <span class="nf">streamRange</span><span class="o">(</span><span class="n">lo</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">hi</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">hi</span><span class="o">)</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">empty</span>
	<span class="k">else</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">cons</span><span class="o">(</span><span class="n">lo</span><span class="o">,</span> <span class="nf">streamRange</span><span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">))</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Stream</code> supports almost all methods of <code class="language-plaintext highlighter-rouge">List</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Find the second prime number between 1000 and 10000</span>
<span class="o">((</span><span class="mi">1000</span> <span class="n">to</span> <span class="mi">10000</span><span class="o">).</span><span class="py">toStream</span> <span class="n">filter</span> <span class="n">isPrime</span><span class="o">)(</span><span class="mi">1</span><span class="o">)</span>

<span class="c1">// However, :: always produces a List</span>
<span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">===</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span>

<span class="c1">// Use the operator #:: to produce a stream</span>
<span class="n">x</span> <span class="o">#::</span> <span class="n">xs</span> <span class="o">===</span> <span class="nc">Stream</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span>
</code></pre></div></div>

<p>Let’s look at implementing <code class="language-plaintext highlighter-rouge">Stream</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Streams are covariant</span>
<span class="k">trait</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">A</span>
	<span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
	<span class="c1">// ...</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
	<span class="c1">// t param is call by name parameter, whereas for lists,</span>
	<span class="c1">// t would be call by value</span>
	<span class="k">def</span> <span class="nf">cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">h</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">t</span> <span class="k">=&gt;</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>
		<span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="n">h</span>
		<span class="k">def</span> <span class="nf">tail</span> <span class="k">=</span> <span class="n">t</span> <span class="c1">// t will be evaluated the first time tail is called</span>
	<span class="o">}</span>

	<span class="c1">// Notice cons and empty are members of Stream</span>
	<span class="k">def</span> <span class="nf">empty</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Strean</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
		<span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"empty.head"</span><span class="o">)</span>
		<span class="k">def</span> <span class="nf">tail</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"empty.tail"</span><span class="o">)</span>
	<span class="o">}</span>

	<span class="c1">// Other Stream methods are implemented similarly to List</span>
	<span class="k">def</span> <span class="nf">filter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="k">this</span>
		<span class="c1">// tail.filter(p) is in a cons for lazy evaluation</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">p</span><span class="o">(</span><span class="n">head</span><span class="o">))</span> <span class="nf">cons</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="nv">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">p</span><span class="o">))</span>
		<span class="k">else</span> <span class="nv">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>

	<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">head</span>
		<span class="k">else</span> <span class="nv">tail</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s now see an exercise.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We've modified streamRange to the following:</span>
<span class="k">def</span> <span class="nf">streamRange</span><span class="o">(</span><span class="n">lo</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">hi</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
	<span class="nf">println</span><span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="s">" "</span><span class="o">)</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">hi</span><span class="o">)</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">empty</span>
	<span class="k">else</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">cons</span><span class="o">(</span><span class="n">lo</span><span class="o">,</span> <span class="nf">streamRange</span><span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// Evaluate streamRange(1, 10).take(3).toList</span>
<span class="c1">// streamRange(1, 10) returns a stream, and so does take</span>
<span class="c1">// So, it would print</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="c1">// and evaluate to</span>
<span class="o">[</span><span class="err">1</span>, <span class="err">2</span>, <span class="err">3</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="lazy-evaluation">Lazy Evaluation</h2>

<p>Our implementation of <code class="language-plaintext highlighter-rouge">Stream</code> recomputes tail each time it’s called, which is very inefficient. Instead, let’s use <em>lazy evaluation</em> to store the result of the first evaluation of tail and return it on each subsequent call. We can do this because in a purely functional language, an expression should return the same result every time.</p>

<p>Recall and compare the other evaluation schemes we’ve seen:</p>

<ul>
  <li>by-name evaluation ⇒ evaluate the expression every time</li>
  <li>strict evaluation ⇒ normal parameters and <code class="language-plaintext highlighter-rouge">val</code> definitions</li>
  <li>lazy evaluation ⇒ evaluate the expression by-name, and then use strict evaluation afterwards</li>
</ul>

<p>Lazy evaluation is very attractive because it is optimized to avoid both unnecessary and repeated computation. In some programming languages, i.e. Haskell, all evaluations are lazy by default. However, the downside to using it is that lazy evaluations are unpredictable in when computations happen and how much space they take.</p>

<p>Scala uses strict evaluation by default by allows lazy evaluation using the <code class="language-plaintext highlighter-rouge">lazy</code> keyword.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="n">expr</span> <span class="c1">// expr is not evalauted until someone calls x</span>

<span class="c1">// Consider the following program</span>
<span class="k">def</span> <span class="nf">expr</span> <span class="k">=</span> <span class="o">{</span>
	<span class="c1">// x prints immediately when expr is evaluated</span>
	<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="o">{</span> <span class="nf">print</span><span class="o">(</span><span class="s">"x"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
	<span class="k">lazy</span> <span class="k">val</span> <span class="nv">y</span> <span class="k">=</span> <span class="o">{</span> <span class="nf">print</span><span class="o">(</span><span class="s">"y"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>
	<span class="k">def</span> <span class="nf">z</span> <span class="k">=</span> <span class="o">{</span> <span class="nf">print</span><span class="o">(</span><span class="s">"z"</span><span class="o">);</span> <span class="mi">3</span> <span class="o">}</span>
	<span class="c1">// then, z is evaluated and so is y from z + y + ...</span>
	<span class="c1">// x is not printed since it has been evaluated</span>
	<span class="c1">// z would be printed</span>
	<span class="c1">// y, x are not printed since they have been evaluated</span>
	<span class="n">z</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
<span class="o">}</span>

<span class="c1">// What does expr print?</span>
<span class="n">expr</span>
<span class="c1">// prints</span>
<span class="n">x</span>
<span class="n">z</span>
<span class="n">y</span>
<span class="n">z</span>
<span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p>To make our streams more efficient, we only have to change our implementation of <code class="language-plaintext highlighter-rouge">Stream.cons</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">h</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">t</span> <span class="k">=&gt;</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="n">h</span>
	<span class="k">lazy</span> <span class="k">val</span> <span class="nv">tail</span> <span class="k">=</span> <span class="n">t</span>
	<span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>To convince ourselves that the implementation of streams really avoids unnecessary computation, let’s trace an expression evaluation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="nf">streamRange</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="mi">10000</span><span class="o">)</span> <span class="n">filter</span> <span class="n">isPrime</span><span class="o">)</span> <span class="n">apply</span> <span class="mi">1</span>
<span class="o">===</span> <span class="o">(</span> <span class="c1">// expand streamRange</span>
	<span class="nf">if</span> <span class="o">(</span><span class="mi">1000</span> <span class="o">&gt;=</span> <span class="mi">10000</span><span class="o">)</span> <span class="n">empty</span>
	<span class="k">else</span> <span class="nf">cons</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="nf">streamRange</span><span class="o">(</span><span class="mi">1000</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">10000</span><span class="o">)</span>
<span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">===</span> <span class="c1">// evaluate if</span>
	<span class="nf">cons</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="nf">streamRange</span><span class="o">(</span><span class="mi">1000</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">10000</span><span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="c1">// Abbreviate cons(1000, streamRange(1000 + 1, 10000) to C1</span>
<span class="o">===</span> <span class="o">(</span>
	<span class="nf">if</span> <span class="o">(</span><span class="nv">C1</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="n">C1</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">isPrime</span><span class="o">(</span><span class="nv">C1</span><span class="o">.</span><span class="py">head</span><span class="o">))</span> <span class="nf">cons</span><span class="o">(</span><span class="nv">C1</span><span class="o">.</span><span class="py">head</span><span class="o">,</span> <span class="nv">C1</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">))</span>
	<span class="k">else</span> <span class="nv">C1</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">))</span>
<span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">===</span> <span class="c1">// evalulae ifs</span>
	<span class="nv">C1</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">===</span> <span class="nf">streamRange</span><span class="o">(</span><span class="mi">1001</span><span class="o">,</span> <span class="mi">10000</span><span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="c1">// ... until the first prime number until the prime 1009</span>
<span class="o">===</span> <span class="nf">streamRange</span><span class="o">(</span><span class="mi">1009</span><span class="o">,</span> <span class="mi">10000</span><span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">===</span> <span class="nf">cons</span><span class="o">(</span><span class="mi">1009</span><span class="o">,</span> <span class="nf">streamRange</span><span class="o">(</span><span class="mi">1009</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">10000</span><span class="o">)).</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="c1">// Abbreviate cons(1009, streamRange(1009 + 1, 10000) to C2</span>
<span class="o">===</span> <span class="nv">C2</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">===</span>  <span class="c1">// evaluate filter</span>
	<span class="nf">cons</span><span class="o">(</span><span class="mi">1009</span><span class="o">,</span> <span class="nv">C2</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">)).</span><span class="py">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">===</span> <span class="c1">// evaluate apply, ask for index n = 1</span>
	<span class="nf">if</span> <span class="o">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nf">cons</span><span class="o">(</span><span class="mi">1009</span><span class="o">,</span> <span class="nv">C2</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">)).</span><span class="py">head</span>
	<span class="k">else</span> <span class="nf">cons</span><span class="o">(</span><span class="mi">1009</span><span class="o">,</span> <span class="nv">C2</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">)).</span><span class="py">tail</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">===</span>
	<span class="nf">cons</span><span class="o">(</span><span class="mi">1009</span><span class="o">,</span> <span class="nv">C2</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">)).</span><span class="py">tail</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">===</span>
	<span class="nv">C2</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">===</span>
	<span class="nf">streamRange</span><span class="o">(</span><span class="mi">1010</span><span class="o">,</span> <span class="mi">10000</span><span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="c1">// ... until the second prime 1013</span>
<span class="o">===</span>
	<span class="nf">streamRange</span><span class="o">(</span><span class="mi">1013</span><span class="o">,</span> <span class="mi">10000</span><span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">===</span>
	<span class="nf">cons</span><span class="o">(</span><span class="mi">1013</span><span class="o">,</span> <span class="nf">streamRange</span><span class="o">(</span><span class="mi">1013</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">10000</span><span class="o">)).</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="c1">// Abbreviate cons(1013, streamRange(1013 + 1, 10000)) to C3</span>
<span class="o">===</span> <span class="nv">C3</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">).</span><span class="py">apply</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">===</span> <span class="nf">cons</span><span class="o">(</span><span class="mi">1013</span><span class="o">,</span> <span class="nv">C3</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">isPrime</span><span class="o">)).</span><span class="py">apply</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// evaluate filter</span>
<span class="o">===</span> <span class="mi">1013</span> <span class="c1">// by evaluate apply</span>

<span class="c1">// We never look for prime numbers past 1013</span>
</code></pre></div></div>

<h2 id="computing-with-infinite-sequences">Computing with Infinite Sequences</h2>

<p>By not defining an end to a stream, we can define an infinite stream.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// gives a stream of all numbers from a given start</span>
<span class="k">def</span> <span class="nf">from</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">n</span> <span class="o">#::</span> <span class="nf">from</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="c1">// stream of all natural numbers</span>
<span class="k">val</span> <span class="nv">nats</span> <span class="k">=</span> <span class="nf">from</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="c1">// stream of all multiples of 4</span>
<span class="n">nats</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>Let’s implement the Sieve of Eratosthenes, which is an algorithm to calculate all prime numbers. It works like this:</p>

<ol>
  <li>Start with all integers from 2, the first prime number.</li>
  <li>Eliminate all multiples of 2.</li>
  <li>3 will be the next prime number.</li>
  <li>Eliminate all multiples of 3.</li>
  <li>Iterate forever. At each step, the first number in the list is a prime number and we eliminate all its multiples.</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sieve</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
	<span class="nv">s</span><span class="o">.</span><span class="py">head</span> <span class="o">#::</span> <span class="nf">sieve</span><span class="o">(</span><span class="nv">s</span><span class="o">.</span><span class="py">tail</span> <span class="nf">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="nv">s</span><span class="o">.</span><span class="py">head</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">primes</span> <span class="k">=</span> <span class="nf">sieve</span><span class="o">(</span><span class="nf">from</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</code></pre></div></div>

<p>Let’s now implement a function to calculate square roots. Recall that the algorithm tries to converge guesses on a single square root, which we can now express as an infinite converging sequence.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sqrtStream</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">improve</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">guess</span> <span class="o">+</span> <span class="n">x</span> <span class="o">/</span> <span class="n">guess</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="c1">// guess 1 first</span>
	<span class="k">lazy</span> <span class="k">val</span> <span class="nv">guesses</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">#::</span> <span class="o">(</span><span class="n">guesses</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span>
	<span class="n">guesses</span>
<span class="o">}</span>

<span class="c1">// We can now define the termination sequence separately</span>
<span class="k">def</span> <span class="nf">isGoodEnough</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span>
	<span class="nv">math</span><span class="o">.</span><span class="py">abs</span><span class="o">((</span><span class="n">guess</span> <span class="o">*</span> <span class="n">guess</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span> <span class="o">/</span> <span class="n">x</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mf">0.0001</span>

<span class="nf">sqrtStream</span><span class="o">(</span><span class="mi">4</span><span class="o">).</span><span class="py">take</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">toList</span>
<span class="o">===</span> <span class="mi">1</span> <span class="o">#::</span> <span class="o">(</span><span class="n">guesses</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span>
<span class="o">===</span> <span class="mi">1</span> <span class="o">#::</span> <span class="o">((</span><span class="mi">1</span> <span class="o">#::</span> <span class="o">(</span><span class="n">guesses</span> <span class="n">map</span> <span class="n">improve</span><span class="o">))</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span>
<span class="c1">// evaluate outer improve for 1 map improve</span>
<span class="o">===</span> <span class="mi">1</span> <span class="o">#::</span> <span class="mf">2.5</span> <span class="o">#::</span> <span class="o">((</span><span class="n">guesses</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span>
<span class="c1">// substitute innermost guesses with 1 #:: (guesses map improve)</span>
<span class="o">===</span> <span class="mi">1</span> <span class="o">#::</span> <span class="mf">2.5</span> <span class="o">#::</span> <span class="o">(((</span><span class="mi">1</span> <span class="o">#::</span> <span class="o">(</span><span class="n">guesses</span> <span class="n">map</span> <span class="n">improve</span><span class="o">))</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span>
<span class="o">===</span> <span class="mi">1</span> <span class="o">#::</span> <span class="mf">2.5</span> <span class="o">#::</span> <span class="o">((</span><span class="mf">2.5</span> <span class="o">#::</span> <span class="o">(</span><span class="n">guesses</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span> <span class="n">map</span> <span class="n">improve</span><span class="o">)</span>
<span class="o">===</span> <span class="mi">1</span> <span class="o">#::</span> <span class="mf">2.5</span> <span class="o">#::</span> <span class="mf">2.05</span> <span class="o">#::</span> <span class="o">...</span>

<span class="c1">// just the guesses that are good enoguh</span>
<span class="nf">sqrtStream</span><span class="o">(</span><span class="mi">4</span><span class="o">).</span><span class="py">filter</span><span class="o">(</span><span class="nf">isGoodEnough</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">4</span><span class="o">)).</span><span class="py">take</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">toList</span>
</code></pre></div></div>

<p>Let’s now do an exercise. Consider two ways to express the infinite stream of multiples of a given number N.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">xs</span> <span class="k">=</span> <span class="nf">from</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="n">N</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">ys</span> <span class="k">=</span>  <span class="nf">from</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="nf">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">xs</code> would generate its examples faster since it doesn’t generate unnecessary elements.</p>

<h2 id="case-study-the-water-pouring-problem">Case Study: The Water Pouring Problem</h2>

<p>Let’s say you’re given a faucet, a sink, and glasses of varying sizes. We must produce a given volume of water in a glass.</p>

<p>We could represent this problem in code like this:</p>

<ul>
  <li>Glass ⇒ <code class="language-plaintext highlighter-rouge">Int</code></li>
  <li>State ⇒ <code class="language-plaintext highlighter-rouge">Vector[Glass]</code></li>
  <li>Moves: <code class="language-plaintext highlighter-rouge">Empty(glass), Fill(glass), Pour(from, to)</code></li>
</ul>

<p>We can represent the solution as a BFS, where we generate all paths from the starting state until we find the correct state or we have exhausted all possible paths.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Given the</span>
<span class="k">class</span> <span class="nc">Pouring</span><span class="o">(</span><span class="n">capacity</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>  <span class="o">{</span>
	<span class="c1">// States</span>
	<span class="k">type</span> <span class="kt">State</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
	<span class="c1">// initial state is all glasses empty</span>
	<span class="k">val</span> <span class="nv">initialState</span> <span class="k">=</span> <span class="n">capacity</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="o">)</span>

	<span class="c1">// Moves</span>
	<span class="k">trait</span> <span class="nc">Move</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">change</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span>
	<span class="o">}</span>
	<span class="k">case</span> <span class="k">class</span> <span class="nc">Empty</span><span class="o">(</span><span class="n">glass</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Move</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">change</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span> <span class="k">=</span> <span class="n">state</span> <span class="nf">updated</span> <span class="o">(</span><span class="n">glass</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
	<span class="o">}</span>
	<span class="k">case</span> <span class="k">class</span> <span class="nc">Fill</span><span class="o">(</span><span class="n">glass</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Move</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">change</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span> <span class="k">=</span> <span class="n">state</span> <span class="nf">updated</span> <span class="o">(</span><span class="n">glass</span><span class="o">,</span> <span class="nf">capacity</span><span class="o">(</span><span class="n">glass</span><span class="o">))</span>
	<span class="o">}</span>
	<span class="k">case</span> <span class="k">class</span> <span class="nc">Pour</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Move</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">change</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
			<span class="c1">// minimum of (amount in from) and (free space in to)</span>
			<span class="k">val</span> <span class="nv">amount</span> <span class="k">=</span> <span class="nf">state</span><span class="o">(</span><span class="n">from</span><span class="o">)</span> <span class="nf">min</span> <span class="o">(</span><span class="nf">capacity</span><span class="o">(</span><span class="n">to</span><span class="o">)</span> <span class="o">-</span> <span class="nf">state</span><span class="o">(</span><span class="n">to</span><span class="o">))</span>
			<span class="n">state</span> <span class="nf">updated</span> <span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="nf">state</span><span class="o">(</span><span class="n">from</span><span class="o">)</span> <span class="o">-</span> <span class="n">amount</span><span class="o">)</span>
			<span class="n">state</span> <span class="nf">updated</span> <span class="o">(</span><span class="n">to</span><span class="o">,</span> <span class="nf">state</span><span class="o">(</span><span class="n">to</span><span class="o">)</span> <span class="o">+</span> <span class="n">amount</span><span class="o">)</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="c1">// Paths</span>
	<span class="c1">// put endState as a value to avoid recomputation of it</span>
	<span class="k">class</span> <span class="nc">Path</span><span class="o">(</span><span class="n">history</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Move</span><span class="o">],</span> <span class="k">val</span> <span class="nv">endState</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// the newest move is appended to the head, not the tail</span>
		<span class="k">def</span> <span class="nf">extend</span><span class="o">(</span><span class="n">move</span><span class="k">:</span> <span class="kt">Move</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Path</span><span class="o">(</span><span class="n">move</span> <span class="o">::</span> <span class="n">history</span><span class="o">,</span> <span class="n">move</span> <span class="n">change</span> <span class="n">endState</span><span class="o">)</span>
		<span class="c1">// reverse the history for printing</span>
		<span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span> <span class="o">(</span><span class="nv">history</span><span class="o">.</span><span class="py">reverse</span> <span class="n">mkString</span> <span class="s">" "</span><span class="o">)</span> <span class="o">+</span> <span class="s">"--&gt;"</span> <span class="o">+</span> <span class="n">endState</span>
	<span class="o">}</span>

	<span class="k">val</span> <span class="nv">initialPath</span> <span class="k">=</span> <span class="nc">Path</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="n">initialState</span><span class="o">)</span>

	<span class="k">def</span> <span class="nf">from</span><span class="o">(</span><span class="n">paths</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Path</span><span class="o">],</span> <span class="n">explored</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">State</span><span class="o">])</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Path</span><span class="o">]]</span> <span class="k">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="nv">paths</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">empty</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="k">val</span> <span class="nv">more</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
				<span class="n">path</span> <span class="k">&lt;-</span> <span class="n">paths</span>
				<span class="n">next</span> <span class="k">&lt;-</span> <span class="n">moves</span> <span class="n">map</span> <span class="nv">path</span><span class="o">.</span><span class="py">extend</span>
				<span class="k">if</span> <span class="o">!(</span><span class="n">explored</span> <span class="n">contains</span> <span class="nv">next</span><span class="o">.</span><span class="py">endState</span><span class="o">)</span>
			<span class="o">}</span> <span class="k">yield</span> <span class="n">next</span>
			<span class="n">paths</span> <span class="o">#::</span> <span class="nf">from</span><span class="o">(</span><span class="n">more</span><span class="o">,</span> <span class="n">explored</span> <span class="o">++</span> <span class="o">(</span><span class="n">more</span> <span class="nf">map</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">endState</span><span class="o">)))</span>
		<span class="o">}</span>

	<span class="c1">// Set(initialPath).isEmpty === false</span>
	<span class="k">val</span> <span class="nv">pathSets</span> <span class="k">=</span> <span class="nf">from</span><span class="o">(</span><span class="nc">Set</span><span class="o">(</span><span class="n">initialPath</span><span class="o">),</span> <span class="nc">Set</span><span class="o">(</span><span class="n">initialPath</span><span class="o">))</span>

	<span class="k">def</span> <span class="nf">solution</span><span class="o">(</span><span class="n">target</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Path</span><span class="o">]</span> <span class="k">=</span>
		<span class="k">for</span> <span class="o">{</span>
			<span class="n">pathSet</span> <span class="k">&lt;-</span> <span class="n">pathSets</span>
			<span class="n">path</span> <span class="k">&lt;-</span> <span class="n">pathSet</span>
			<span class="k">if</span> <span class="nv">path</span><span class="o">.</span><span class="py">endState</span> <span class="n">contains</span> <span class="n">target</span>
		<span class="o">}</span> <span class="k">yield</span> <span class="n">path</span>

	<span class="c1">// index the glasses</span>
	<span class="k">val</span> <span class="nv">glasses</span> <span class="k">=</span> <span class="mi">0</span> <span class="n">until</span> <span class="nv">capacity</span><span class="o">.</span><span class="py">length</span>
	<span class="k">val</span> <span class="nv">moves</span> <span class="k">=</span>
		<span class="o">(</span><span class="nf">for</span> <span class="o">(</span><span class="n">g</span> <span class="k">&lt;-</span> <span class="n">glasses</span><span class="o">)</span> <span class="k">yield</span> <span class="nc">Empty</span><span class="o">(</span><span class="n">g</span><span class="o">))</span> <span class="o">++</span> <span class="c1">// we can empty a glass</span>
		<span class="o">(</span><span class="nf">for</span> <span class="o">(</span><span class="n">g</span> <span class="k">&lt;-</span> <span class="n">glasses</span><span class="o">)</span> <span class="k">yield</span> <span class="nc">Fill</span><span class="o">(</span><span class="n">g</span><span class="o">))</span> <span class="o">++</span> <span class="c1">// we can fill a glass</span>
		<span class="o">(</span><span class="nf">for</span> <span class="o">(</span><span class="n">from</span> <span class="k">&lt;-</span> <span class="n">glasses</span><span class="o">;</span> <span class="n">to</span> <span class="k">&lt;-</span> <span class="n">glasses</span> <span class="k">if</span> <span class="n">from</span> <span class="o">!=</span> <span class="n">to</span><span class="o">)</span>
			<span class="k">yield</span> <span class="nc">Pour</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">))</span> <span class="c1">// or we can pour from one glass to another</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">problem</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Pouring</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">))</span>
<span class="nv">problem</span><span class="o">.</span><span class="py">solution</span><span class="o">(</span><span class="mi">6</span><span class="o">)</span>
</code></pre></div></div>

<p>Guiding principles for good design:</p>

<ul>
  <li>Name everything you can</li>
  <li>Put operations into natural scopes</li>
  <li>Keep degrees of freedom for future refinements</li>
</ul>

<h1 id="week-3">Week 3</h1>

<h2 id="type-directed-programming">Type-Directed Programming</h2>

<p>We’ve previously seen that the Scala compiler is able to infer types given values.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="mi">42</span> <span class="c1">// Scala infers x:Int</span>
<span class="k">val</span> <span class="nv">y</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Scala infers y:Int</span>
</code></pre></div></div>

<p>It’s also possible to use <em>type-directed programming</em> to infer <em>values given types</em>. Consider a sorting method that can sort multiple types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// use Scala's native ordering to compare types</span>
<span class="k">import</span> <span class="nn">scala.math.Ordering</span>
<span class="k">def</span> <span class="nf">sort</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="o">...</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">ord</span><span class="o">.</span><span class="py">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="o">...</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// Ordering.Int and Ordering.String are _values_ defined by Scala</span>
<span class="nf">sort</span><span class="o">(</span><span class="n">xs</span><span class="o">)(</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span><span class="o">)</span> <span class="c1">// sort infers that xs: List[Int]</span>
<span class="nf">sort</span><span class="o">(</span><span class="n">strings</span><span class="o">)(</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">String</span><span class="o">)</span> <span class="c1">// sort infers that strings: List[String]</span>
</code></pre></div></div>

<p>In fact, it’s possible to make the compiler infer the ordering argument for us by marking the <code class="language-plaintext highlighter-rouge">Ordering</code> parameter as <code class="language-plaintext highlighter-rouge">implicit</code>. The compiler will then look for <em>candidate definitions</em> that match the expected type.</p>

<p>Restrictions apply to how <em>implicit parameters</em> are used:</p>

<ul>
  <li>A method can only have one implicit parameter list, and it must be the last parameter list given</li>
  <li>You can explicitly pass an argument marked as <code class="language-plaintext highlighter-rouge">implicit</code>, but it’s usually left out</li>
  <li>
    <p>If there is more than one candidate definition possible and neither is more <em>specific</em> than the other, an ambiguity error will be thrown</p>

    <p>A definition <code class="language-plaintext highlighter-rouge">a: A</code> is more specific than a definition <code class="language-plaintext highlighter-rouge">b: B</code> if:</p>

    <ul>
      <li>type <code class="language-plaintext highlighter-rouge">A</code> has more fixed parts</li>
      <li><code class="language-plaintext highlighter-rouge">a</code> is defined in a class or object which is a subclass of the class defining b</li>
    </ul>
  </li>
  <li>If there is no candidate definition possible, an error is thrown</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sort</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="o">...</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">ord</span><span class="o">.</span><span class="py">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="o">...</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// Now we can call sort like this</span>
<span class="nf">sort</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span> <span class="c1">// Scala infers that A: Int from xs, and then infers Ordering[Int]</span>
<span class="nf">sort</span><span class="o">(</span><span class="n">strings</span><span class="o">)</span>
</code></pre></div></div>

<p>For a given type T, the compiler looks for candidate definitions that:</p>

<ul>
  <li>have type T</li>
  <li>are marked implicit</li>
  <li>
    <p>are visible at the point of the function call (lexical scope), or are defined in a <em>companion</em> object <em>associated</em> with T (implicit scope)</p>

    <p><strong>companion object</strong> ⇒ object with the same name as a class and declared in the same file as that class</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Pizza</span> <span class="o">{}</span>
<span class="c1">// object Pizza is a companion object to class Pizza</span>
<span class="k">object</span> <span class="nc">Pizza</span> <span class="o">{}</span>

<span class="c1">// class Pizza and object Pizza can access each other's private members</span>
</code></pre></div>    </div>

    <p>For a type <code class="language-plaintext highlighter-rouge">F[C]</code>, the implicit scope includes:</p>

    <ul>
      <li>the companions of both <code class="language-plaintext highlighter-rouge">F</code> and <code class="language-plaintext highlighter-rouge">C</code></li>
      <li>the companions of the base classes of <code class="language-plaintext highlighter-rouge">F</code> and <code class="language-plaintext highlighter-rouge">C</code>, including package objects such as <code class="language-plaintext highlighter-rouge">p</code> for <code class="language-plaintext highlighter-rouge">p.F</code></li>
    </ul>

    <p>For example, in the following type hierarchy:</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Assume all of these types have their own companion objects</span>
<span class="k">trait</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">trait</span> <span class="nc">Bar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">trait</span> <span class="nc">Baz</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Bar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">trait</span> <span class="nc">X</span>
<span class="k">trait</span> <span class="nc">Y</span> <span class="k">extends</span> <span class="n">X</span>
</code></pre></div>    </div>

    <p>If an implicit value of type Bar[Y] is required, the compiler will look for candidate definitions in the following companion objects:</p>

    <ul>
      <li>Bar, because it is a part of Bar[Y]</li>
      <li>Y, because it is a part of Bar[Y]</li>
      <li>Foo, because it is a parent type of Bar</li>
      <li>X, because it is a parent type of Y</li>
    </ul>

    <p>However, the companion object Baz will not be visited.</p>
  </li>
</ul>

<p><strong>implicit definition</strong> ⇒ definition qualified with <code class="language-plaintext highlighter-rouge">implicit</code> keyword</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Ordering</span> <span class="o">{</span>
	<span class="c1">// an implicit definition of an implicit value</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">Int</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">orderingPair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span>
	<span class="k">implicit</span> <span class="n">orderingA</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="c1">// implicit parameter</span>
	<span class="n">orderingB</span><span class="k">:</span> <span class="kt">ordering</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="c1">// type parameter</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>Let’s see some examples of implicit parameter calling.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">universal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">int</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">???</span>
<span class="k">def</span> <span class="nf">f</span><span class="o">(</span><span class="k">implicit</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">()</span>
<span class="c1">// Which implicit definition matches n when f is called?</span>
<span class="n">f</span>
<span class="c1">// Because universal takes A, int is more specific, so n = int</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">A</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">}</span>
<span class="k">trait</span> <span class="nc">B</span> <span class="k">extends</span> <span class="n">A</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">y</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">def</span> <span class="nf">f</span><span class="o">(</span><span class="k">implicit</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">()</span>
	<span class="c1">// Which implicit definition matches n when f is called?</span>
  <span class="n">f</span>
<span class="o">}</span>
<span class="c1">// Because y is in a subtrait of A, y is more specific, so n = y</span>
</code></pre></div></div>

<p>Syntactic sugar allows for the omission of the implicit parameter list in definitions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A: Ordering is a context bound</span>
<span class="k">def</span> <span class="nf">printSorted</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Ordering</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="nf">sort</span><span class="o">(</span><span class="n">as</span><span class="o">))</span>
<span class="o">}</span>
<span class="o">===</span>
<span class="k">def</span> <span class="nf">printSorted</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ev1</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="nf">sort</span><span class="o">(</span><span class="n">as</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can check the implicit value for any given type by calling the function <code class="language-plaintext highlighter-rouge">implicitly</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// definition of implicitly</span>
<span class="k">def</span> <span class="nf">implicitly</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">value</span>

<span class="n">implicitly</span><span class="o">[</span><span class="kt">Ordering</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
<span class="o">===</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">scala</span><span class="o">.</span><span class="py">math</span><span class="o">.</span><span class="py">Ordering$Int$</span><span class="k">@</span><span class="mi">73564</span><span class="n">ab0</span>
</code></pre></div></div>

<h2 id="type-classes">Type Classes</h2>

<p><strong>type class</strong> ⇒ class defining multiple implicit values of differing types which the compiler resolves between e.g. <code class="language-plaintext highlighter-rouge">Ordering</code>, which defines <code class="language-plaintext highlighter-rouge">implicit val Ordering.Int: Ordering[Int]</code> and <code class="language-plaintext highlighter-rouge">implicit val Ordering.String: Ordering[String]</code></p>

<p>Using type classes, we can extend data types without changing the original definition of those datatypes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Suppose we wanted to compare rationals</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">denom</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="c1">// Instead of changing the class, we can add an implicit ordering</span>
<span class="k">object</span> <span class="nc">Rational</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">orderingRational</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Rational</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">Rational</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">compare</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
        <span class="nv">q</span><span class="o">.</span><span class="py">num</span> <span class="o">*</span> <span class="nv">r</span><span class="o">.</span><span class="py">denom</span> <span class="o">-</span> <span class="nv">r</span><span class="o">.</span><span class="py">num</span> <span class="o">*</span> <span class="nv">q</span><span class="o">.</span><span class="py">denom</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In order to make sure that a type class is correct, we can define certain <em>laws</em> about the instances of that type. For example, instances of <code class="language-plaintext highlighter-rouge">Ordering[A]</code> must satisfy:</p>

<ul>
  <li>inverse ⇒ sign(<code class="language-plaintext highlighter-rouge">compare(x, y)</code>) must be the inverse of sign(<code class="language-plaintext highlighter-rouge">compare(y, x)</code>)</li>
  <li>transitive ⇒ if <code class="language-plaintext highlighter-rouge">compare(x, y) == -1</code> and <code class="language-plaintext highlighter-rouge">compare(y, z) == -1</code>, then <code class="language-plaintext highlighter-rouge">compare(x, z) == -1</code></li>
  <li>consistent ⇒ if <code class="language-plaintext highlighter-rouge">x == y</code>, then sign(<code class="language-plaintext highlighter-rouge">compare(x, z)</code>) is equal to sign(<code class="language-plaintext highlighter-rouge">compare(y, z)</code>)</li>
</ul>

<p>Let’s now write a <code class="language-plaintext highlighter-rouge">Ring</code> type class as an example. A ring in algebra is a set supporting + and *, satisfying the following ring axioms:</p>

<ul>
  <li>
    <ul>
      <li>is associative ⇒ (a + b) + x = a + (b + c)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>is commutative ⇒ a + b = b + a</li>
    </ul>
  </li>
  <li>0 is the additive identity ⇒ a + 0 = 0</li>
  <li>-a is the additive inverse of a ⇒ a + (-a) = 0</li>
  <li>
    <ul>
      <li>is associative ⇒ (a _ b) _ c = a _ (b _ c)</li>
    </ul>
  </li>
  <li>1 is the multiplicative identity ⇒ a * 1 = a</li>
  <li>left distributivity ⇒ a _ (b + c) = a _ b + a * c</li>
  <li>right distributivity ⇒ (b + c) _ a = b _ a + c * a</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ring type class</span>
<span class="k">trait</span> <span class="nc">Ring</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
  <span class="k">def</span> <span class="nf">mult</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
  <span class="k">def</span> <span class="nf">inverse</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
  <span class="k">def</span> <span class="nf">zero</span><span class="k">:</span> <span class="kt">A</span>
  <span class="k">def</span> <span class="nf">one</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Ring</span> <span class="o">{</span>
	<span class="c1">// instance of Ring[Int]</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">ringInt</span><span class="k">:</span> <span class="kt">Ring</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Ring</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">def</span> <span class="nf">mult</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
    <span class="k">def</span> <span class="nf">zero</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">one</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// law to check that + is associative on rings</span>
<span class="k">def</span> <span class="nf">plusAssociativity</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">z</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ring</span><span class="k">:</span> <span class="kt">Ring</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="nv">ring</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="nv">ring</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="o">==</span> <span class="nv">ring</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nv">ring</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="conditional-implicit-definitions">Conditional Implicit Definitions</h2>

<p>Notice that when we compare sequences of characters, like “abc” and “abd” for instance, all we’re doing is character comparison one letter at a time. We can generalize these comparisons in sequence using <code class="language-plaintext highlighter-rouge">Ordering[List[A]]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// takes an implicit parameter of Ordering[A]</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">orderingList</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">compare</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
      <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xsTail</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ysTail</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="nv">ord</span><span class="o">.</span><span class="py">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="c1">// compare x and y</span>
					<span class="c1">// if x and y were the same, keep comparing with list remaining</span>
          <span class="nf">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">c</span> <span class="k">else</span> <span class="nf">compare</span><span class="o">(</span><span class="n">xsTail</span><span class="o">,</span> <span class="n">ysTail</span><span class="o">)</span>
        <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">0</span> <span class="c1">// two empty lists are equal</span>
        <span class="nf">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="mi">1</span> <span class="c1">// full list &gt; empty list</span>
        <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// empty list &lt; full list</span>
      <span class="o">}</span>
  <span class="o">}</span>

<span class="c1">// We can use this to sort a list of numbers</span>
<span class="k">val</span> <span class="nv">xss</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="c1">// &gt; List[List[Int]] = List(List(1, 2, 3), List(1), List(1, 1, 3))</span>

<span class="nf">sort</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span> <span class="c1">// compiler fills in the following implicit defs</span>
	<span class="o">===</span> <span class="n">sort</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="n">xss</span><span class="o">)</span>
	<span class="o">===</span> <span class="n">sort</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="n">xss</span><span class="o">)(</span><span class="nf">orderingList</span><span class="o">(</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span><span class="o">))</span>
<span class="c1">// &gt; List[List[Int]] = List(List(1), List(1, 1, 3), List(1, 2, 3))</span>
</code></pre></div></div>

<p>The compiler can recursively look for implicit definitions by looking for the arguments of arguments.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">a</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">aToB</span><span class="o">(</span><span class="k">implicit</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">bToC</span><span class="o">(</span><span class="k">implicit</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">cToD</span><span class="o">(</span><span class="k">implicit</span> <span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">implicitly</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
	<span class="o">===</span> <span class="nf">cToD</span><span class="o">(</span><span class="k">implicit</span> <span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span>
	<span class="o">===</span> <span class="nf">cToD</span><span class="o">(</span><span class="nf">bToC</span><span class="o">(</span><span class="k">implicit</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">))</span>
	<span class="o">===</span> <span class="nf">cToD</span><span class="o">(</span><span class="nf">bToC</span><span class="o">(</span><span class="nf">aToB</span><span class="o">(</span><span class="k">implicit</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)))</span>
	<span class="o">===</span> <span class="nf">cToD</span><span class="o">(</span><span class="nf">bToC</span><span class="o">(</span><span class="nf">aToB</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>

<span class="c1">// If no recusion termination is possible, the compiler throws an error</span>
<span class="k">trait</span> <span class="nc">X</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">loop</span><span class="o">(</span><span class="k">implicit</span> <span class="n">x</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">implicitly</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="c1">// throws error</span>
</code></pre></div></div>

<p>Let’s now look at an example where we want to compare movies, which have titles, ratings and durations.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Movie</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">rating</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">duration</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">movies</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="nc">Movie</span><span class="o">(</span><span class="s">"Interstellar"</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">169</span><span class="o">),</span>
  <span class="nc">Movie</span><span class="o">(</span><span class="s">"Inglourious Basterds"</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">140</span><span class="o">),</span>
  <span class="nc">Movie</span><span class="o">(</span><span class="s">"Fight Club"</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">139</span><span class="o">),</span>
  <span class="nc">Movie</span><span class="o">(</span><span class="s">"Zodiac"</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">157</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">def</span> <span class="nf">sort</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">critera</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span>
  <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">orderingPair</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="k">implicit</span>
  <span class="n">orderingA</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
  <span class="n">orderingB</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Ordering</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">compare</span><span class="o">(</span><span class="n">pair1</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">),</span> <span class="n">pair2</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">firstCriteria</span> <span class="k">=</span> <span class="nv">orderingA</span><span class="o">.</span><span class="py">compare</span><span class="o">(</span><span class="nv">pair1</span><span class="o">.</span><span class="py">_1</span><span class="o">,</span> <span class="nv">pair2</span><span class="o">.</span><span class="py">_1</span><span class="o">)</span>
			<span class="c1">// compare by first criteria, then second</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">firstCriteria</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">firstCriteria</span>
      <span class="k">else</span> <span class="nv">orderingB</span><span class="o">.</span><span class="py">compare</span><span class="o">(</span><span class="nv">pair1</span><span class="o">.</span><span class="py">_2</span><span class="o">,</span> <span class="nv">pair2</span><span class="o">.</span><span class="py">_2</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="c1">// sort movies by title, B inferred as String</span>
<span class="nf">sort</span><span class="o">(</span><span class="n">movies</span><span class="o">)(</span><span class="nv">_</span><span class="o">.</span><span class="py">title</span><span class="o">)</span>
<span class="c1">// sort movies by rating, B inferred Int</span>
<span class="nf">sort</span><span class="o">(</span><span class="n">movies</span><span class="o">)(</span><span class="nv">_</span><span class="o">.</span><span class="py">rating</span><span class="o">)</span>

<span class="c1">// sort movies by rating then duration, B inferred as Ordering[(A, B)]</span>
<span class="c1">// which becomes Ordering[(Int, Int)]</span>
<span class="nf">sort</span><span class="o">(</span><span class="n">movies</span><span class="o">)(</span><span class="n">movie</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nv">movie</span><span class="o">.</span><span class="py">rating</span><span class="o">,</span> <span class="nv">movie</span><span class="o">.</span><span class="py">duration</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="implicit-conversions">Implicit Conversions</h2>

<p><strong>implicit conversions</strong> ⇒ implicit methods (or class constructors) that take exactly one non-implicit parameter for automatic conversion between types</p>

<p>Let’s implement JSON library that uses implicit conversions for type coercion.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JSON represented as an AST (Abstract Syntax Tree)</span>
<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Json</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JNumber</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">BigDecimal</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Json</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JString</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Json</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JBoolean</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Json</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JArray</span><span class="o">(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Json</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Json</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">JObject</span><span class="o">(</span><span class="n">fields</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Json</span><span class="o">)*)</span> <span class="k">extends</span> <span class="nc">Json</span>

<span class="k">object</span> <span class="nc">Json</span> <span class="o">{</span>
	<span class="k">import</span> <span class="nn">scala.language.implicitConversions</span>
<span class="c1">// lets us write obj("foo" -&gt; "bar") instead of obj("foo" -&gt; JString("bar"))</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">stringToJson</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Json</span> <span class="o">=</span> <span class="nc">JString</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">intToJson</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Json</span> <span class="o">=</span> <span class="nc">JNumber</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// { "name": "Paul", "age": 42 } would be constructed as</span>
<span class="nc">JObject</span><span class="o">(</span><span class="s">"name"</span> <span class="o">-&gt;</span> <span class="nc">JString</span><span class="o">(</span><span class="s">"Paul"</span><span class="o">),</span> <span class="s">"age"</span> <span class="o">-&gt;</span> <span class="nc">JNumber</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>

<span class="c1">// Let's define an obj function that will make construction less wordy</span>
<span class="k">def</span> <span class="nf">obj</span><span class="o">(</span><span class="n">fields</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Json</span><span class="o">)*)</span><span class="k">:</span> <span class="kt">Json</span> <span class="o">=</span> <span class="nc">JObject</span><span class="o">(</span><span class="n">fields</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>

<span class="c1">// Now we can write</span>
<span class="nf">obj</span><span class="o">(</span><span class="s">"name"</span> <span class="o">-&gt;</span> <span class="s">"Paul"</span><span class="o">,</span> <span class="s">"age"</span> <span class="o">-&gt;</span> <span class="mi">42</span><span class="o">)</span>
<span class="o">===</span> <span class="nf">obj</span><span class="o">(</span> <span class="c1">// compiler does this conversion</span>
		<span class="s">"name"</span> <span class="o">-&gt;</span> <span class="nv">Json</span><span class="o">.</span><span class="py">stringToJson</span><span class="o">(</span><span class="s">"Paul"</span><span class="o">),</span>
		<span class="s">"age"</span> <span class="o">-&gt;</span> <span class="nv">Json</span><span class="o">.</span><span class="py">intToJson</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
	<span class="o">)</span>
</code></pre></div></div>

<p>Along the same lines, let’s now see how to extend a duration library to support cleaner construction syntax.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Duration</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">unit</span><span class="k">:</span> <span class="kt">TimeUnit</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Duration</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">Syntax</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">scala.language.implicitConversions</span>
		<span class="c1">// constructors of implicit classes act as implicit conversions</span>
    <span class="k">implicit</span> <span class="k">class</span> <span class="nc">HasSeconds</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">seconds</span><span class="k">:</span> <span class="kt">Duration</span> <span class="o">=</span> <span class="nc">Duration</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="nv">TimeUnit</span><span class="o">.</span><span class="py">Second</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">delay</span> <span class="k">=</span> <span class="nc">Duration</span><span class="o">(</span><span class="mi">15</span><span class="o">,</span> <span class="nv">TimeUnit</span><span class="o">.</span><span class="py">Second</span><span class="o">)</span>

<span class="c1">// We extend Duration to support this cleaner syntax</span>
<span class="k">val</span> <span class="nv">delay</span> <span class="k">=</span> <span class="mf">15.</span><span class="n">seconds</span>
	<span class="o">===</span> <span class="k">new</span> <span class="nc">HasSeconds</span><span class="o">(</span><span class="mi">15</span><span class="o">).</span><span class="py">seconds</span> <span class="c1">// compiler does this conversion</span>
</code></pre></div></div>

<p>The compiler looks for implicit conversions of an expression <code class="language-plaintext highlighter-rouge">e</code> of a type <code class="language-plaintext highlighter-rouge">T</code> when:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">T</code> does not conform to the expression’s expected type</li>
  <li>in a selection <code class="language-plaintext highlighter-rouge">e.m</code>, if member <code class="language-plaintext highlighter-rouge">m</code> is not accessible on <code class="language-plaintext highlighter-rouge">T</code></li>
  <li>in a selection <code class="language-plaintext highlighter-rouge">e.m(args)</code>, if member <code class="language-plaintext highlighter-rouge">m</code> is accessible on <code class="language-plaintext highlighter-rouge">T</code> but not applicable to the arguments <code class="language-plaintext highlighter-rouge">args</code></li>
</ul>

<p>The compiler looks for implicit conversions in the enclosing lexical scope and the implicit search scope, just like it does with implicit definitions.</p>

<p>Use implicit conversions sparingly, since they can confuse developers reading code.</p>

<h1 id="week-4">Week 4</h1>

<h2 id="functions-and-state">Functions and State</h2>

<p>Recall the substitution model of evaluation, where we evaluate expressions by rewriting them e.g. function applications. The substitution model doesn’t have a concept of time—according to the Church-Rosser Theorem of lambda calculus (confluence), rewritings can be done at any time at any place in a term, and the resulting evaluation would be the same.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// don't call this with negative n</span>
<span class="k">def</span> <span class="nf">iterate</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="k">def</span> <span class="nf">square</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="c1">// Rewriting 1</span>
<span class="nf">iterate</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">===</span> <span class="nf">if</span> <span class="o">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">3</span> <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="nf">square</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="o">===</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="nf">square</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="o">===</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
<span class="o">===</span> <span class="nf">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">9</span> <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="nf">square</span><span class="o">(</span><span class="mi">9</span><span class="o">))</span>
<span class="o">===</span> <span class="mi">9</span>

<span class="c1">// Rewriting 2</span>
<span class="nf">iterate</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">===</span> <span class="nf">if</span> <span class="o">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">3</span> <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="nf">square</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="o">===</span> <span class="nf">if</span> <span class="o">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">3</span> <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">===</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
<span class="o">===</span> <span class="nf">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">9</span> <span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="mi">0</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">square</span><span class="o">,</span> <span class="nf">square</span><span class="o">(</span><span class="mi">9</span><span class="o">))</span>
<span class="o">===</span> <span class="mi">9</span> <span class="c1">// same result</span>
</code></pre></div></div>

<p>stateful object ⇒ object whose behavior is affected by its history e.g. bank account</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Mutable state created by `var`</span>
<span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"abc"</span>
<span class="k">var</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">111</span>

<span class="c1">// Vars can be reassigned</span>
<span class="n">x</span> <span class="k">=</span> <span class="s">"hi"</span>
<span class="n">count</span> <span class="k">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1">// class modelling a bank account</span>
<span class="k">class</span> <span class="nc">BankAccount</span> <span class="o">{</span>
	<span class="k">private</span> <span class="k">var</span> <span class="n">balance</span> <span class="k">=</span> <span class="mi">0</span>

	<span class="k">def</span> <span class="nf">deposit</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">balance</span> <span class="k">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="n">amount</span>

	<span class="k">def</span> <span class="nf">withdraw</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">amount</span> <span class="o">&amp;&amp;</span> <span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">balance</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">balance</span> <span class="k">=</span> <span class="n">balance</span> <span class="o">-</span> <span class="n">amount</span>
			<span class="n">balance</span>
		<span class="o">}</span> <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"insufficient funds"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">acct</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BankAccount</span>
<span class="n">acct</span> <span class="n">deposit</span> <span class="mi">50</span>
<span class="n">acct</span> <span class="n">withdraw</span> <span class="mi">20</span>
<span class="n">acct</span> <span class="n">withdraw</span> <span class="mi">20</span>
<span class="n">acct</span> <span class="n">withdraw</span> <span class="mi">15</span> <span class="c1">// Error, insufficient funds</span>

<span class="c1">// a stateful object, since it behaves statefully</span>
<span class="c1">// even though it has no mutable variables itself</span>
<span class="k">class</span> <span class="nc">BankAccountProzy</span><span class="o">(</span><span class="n">ba</span><span class="k">:</span> <span class="kt">BankAccount</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">deposit</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nv">ba</span><span class="o">.</span><span class="py">deposit</span><span class="o">(</span><span class="n">amount</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">withdraw</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">ba</span><span class="o">.</span><span class="py">withdraw</span><span class="o">(</span><span class="n">amount</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Recall the implementation streams, which used <code class="language-plaintext highlighter-rouge">lazy val</code>. We could also implement non-empty streams using a mutable variable.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">h</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">t</span> <span class="k">=&gt;</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">head</span> <span class="k">=</span> <span class="n">h</span>
	<span class="k">private</span> <span class="k">var</span> <span class="n">tOpt</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
	<span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">tOpt</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
		<span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">tOpt</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">t</span><span class="o">);</span> <span class="n">tail</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Is the result of <code class="language-plaintext highlighter-rouge">cons</code> a stateful object?</p>

<p>It depends! If we assume that the tail operation <code class="language-plaintext highlighter-rouge">t</code> does not have side effects, then the state of <code class="language-plaintext highlighter-rouge">tOpt</code> (cached or not cached) does not have an observable effect outside of <code class="language-plaintext highlighter-rouge">cons</code>, so <code class="language-plaintext highlighter-rouge">cons</code> is still not stateful.</p>

<p>However, if <code class="language-plaintext highlighter-rouge">t</code> had a side effect like a <code class="language-plaintext highlighter-rouge">println</code>, then we would not see that side effect each subsequent time we called <code class="language-plaintext highlighter-rouge">tail</code>, so <code class="language-plaintext highlighter-rouge">cons</code> would be stateful.</p>

<h2 id="identity-and-change">Identity and Change</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Without state, it's easy to decide whether objects are the same</span>
<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="n">E</span><span class="o">;</span> <span class="k">val</span> <span class="nv">y</span> <span class="k">=</span> <span class="n">E</span>
<span class="n">x</span> <span class="o">===</span> <span class="n">y</span>

<span class="c1">// referential transparency</span>
<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="n">E</span><span class="o">;</span> <span class="k">val</span> <span class="nv">y</span> <span class="k">=</span> <span class="n">x</span>
<span class="n">x</span> <span class="o">===</span> <span class="n">y</span>

<span class="c1">// With state, the substitution model doesn't apply</span>
<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BankAccount</span>
<span class="k">val</span> <span class="nv">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BankAccount</span>
<span class="n">x</span> <span class="o">?==</span> <span class="n">y</span>

<span class="c1">// Suppose for all possible functions f performing a sequence of ops S,</span>
<span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">===</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="c1">// then x, y are operationally equivalent</span>
</code></pre></div></div>

<p>operational equivalence ⇒ x and y are operationally equivalent if no possible test can distinguish between them</p>

<p>It’s possible to still use the Substitution Model to reason about programs with state, but we need to add to it the concept of a store that keeps track of all the references. However, this is more complicated and is outside the scope of this course.</p>

<h2 id="loops">Loops</h2>

<p>Variables are enough to model all imperative programs.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We can rewrite this program to not use the while keyword</span>
<span class="k">def</span> <span class="nf">power</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">exp</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
	<span class="k">var</span> <span class="n">r</span> <span class="k">=</span> <span class="mf">1.0</span>
	<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="n">exp</span>
	<span class="c1">// while (i &gt; 0) { r = r * x; i = i - 1 }</span>
	<span class="nc">WHILE</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)({</span><span class="n">r</span> <span class="k">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">x</span><span class="o">;</span> <span class="n">i</span> <span class="k">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">})</span>
	<span class="c1">// notice, () =&gt; { r = r * x; i = i - 1 } would be wrong</span>
	<span class="c1">// because the scope would not allow for i to be changed</span>
	<span class="n">r</span>
<span class="o">}</span>

<span class="c1">// condition and command must be passed by name</span>
<span class="c1">// so they are re-evaluated each time</span>
<span class="k">def</span> <span class="nf">WHILE</span><span class="o">(</span><span class="n">condition</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)(</span><span class="n">command</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">command</span>
		<span class="nf">while</span><span class="o">(</span><span class="n">condition</span><span class="o">)(</span><span class="n">command</span><span class="o">)</span> <span class="c1">// tail recursive, as efficient as loop</span>
	<span class="o">}</span>
	<span class="nf">else</span> <span class="o">()</span>
</code></pre></div></div>

<p>We can also write other control structures:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
	Executes command 1 or more times until condition is true
	Same as a do-while
	REPEAT {
		command
	} UNTIL (condition)
**/</span>

<span class="c1">// a class, because objects in Scala take no params</span>
<span class="k">class</span> <span class="nc">Repeater</span><span class="o">(</span><span class="n">body</span> <span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">UNTIL</span><span class="o">(</span><span class="n">condition</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">body</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">)</span> <span class="o">()</span>
    <span class="k">else</span> <span class="nc">UNTIL</span><span class="o">(</span><span class="n">condition</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Repeater</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">REPEAT</span><span class="o">(</span><span class="n">x</span> <span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Repeater</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nc">Repeater</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// use like this</span>
<span class="k">import</span> <span class="nn">Repeater.REPEAT</span>
<span class="k">var</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">0</span>
<span class="nc">REPEAT</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
  <span class="n">y</span> <span class="k">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span> <span class="nc">UNTIL</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Java's for-loops have a declaration, so they can't be modelled</span>
<span class="c1">// by a higher order function</span>
<span class="nf">for</span><span class="o">(</span><span class="n">int</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="c1">// impossible to model</span>

<span class="c1">// Instead, Scala has this, which is modelled by Collection's foreach</span>
<span class="nf">for</span><span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="c1">// Apply `f` to each element of the collection</span>
<span class="k">def</span> <span class="nf">foreach</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>

<span class="nf">for</span><span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span><span class="o">;</span> <span class="n">j</span> <span class="k">&lt;-</span> <span class="s">"abc"</span><span class="o">)</span> <span class="nf">println</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span>
<span class="o">===</span> <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span><span class="o">)</span> <span class="nf">foreach</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span>
				<span class="s">"abc"</span> <span class="nf">foreach</span><span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">j</span><span class="o">))</span>
		<span class="o">)</span>
</code></pre></div></div>

<h2 id="example-discrete-event-simulation">Example: Discrete Event Simulation</h2>

<p>Let’s build a simple digital circuit simulator. A digit circuit is composed of wires and functional components.</p>

<p>wires ⇒ transport signals transformed by components (must start/end at an input or component)</p>

<p>signal ⇒ either <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code></p>

<p>base components (gates):</p>

<ul>
  <li>
    <p>inverter ⇒ outputs inverse of input</p>

    <p><img src="Untitled.png" alt="Untitled.png" /></p>
  </li>
  <li>
    <p>and gate ⇒ outputs the conjunction of the inputs</p>

    <p><img src="Untitled%201.png" alt="Untitled%201.png" /></p>
  </li>
  <li>
    <p>or gate ⇒ outputs the disjunction of the inputs</p>

    <p><img src="Untitled%202.png" alt="Untitled%202.png" /></p>
  </li>
</ul>

<p>components ⇒ some combination of the base components, each of which has a delay between feeding in the input and getting the output</p>

<p>As an example, this would be a half-adder circuit, which outputs the sum of two inputs as well as the carry. Diagrammed, it looks like this.</p>

<p><img src="Untitled%203.png" alt="Untitled%203.png" /></p>

<p>Mathematically:</p>

\[S = (a \lor  b) \land \neg(a \land b) \\ C = a \land b\]

<p>We can construct a full adder (adds 1 bit) using 2 half adders.</p>

<p><img src="Untitled%204.png" alt="Untitled%204.png" /></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Circuits</span> <span class="k">extends</span> <span class="nc">Gates</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="k">val</span> <span class="nv">d</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
		<span class="k">val</span> <span class="nv">e</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
		<span class="c1">// connect wires using gates</span>
		<span class="nf">orGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
		<span class="nf">andGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
		<span class="nf">inverter</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
		<span class="nf">andGate</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
	<span class="o">}</span>

	<span class="c1">// We can construct a full adder (adds 1 bit) using 2 half adders</span>
	<span class="k">def</span> <span class="nf">fullAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">cin</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">sum</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">cout</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
		<span class="k">val</span> <span class="nv">c1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
		<span class="k">val</span> <span class="nv">c2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
		<span class="nf">halfAdder</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">cin</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">c1</span><span class="o">)</span>
		<span class="nf">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span>
		<span class="nf">orGate</span><span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">,</span> <span class="n">cout</span><span class="o">)</span>
	<span class="o">}</span>

	<span class="c1">// f =&gt; a !== b</span>
	<span class="k">def</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="k">val</span> <span class="nv">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">g</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
		<span class="nf">inverter</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="c1">// d = !a</span>
		<span class="nf">inverter</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="c1">// e = !b</span>
		<span class="nf">andGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="c1">// f = a ^ !b</span>
		<span class="nf">andGate</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span> <span class="c1">// g = b ^ !a</span>
		<span class="nf">orGate</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="c1">// c = (a ^ !b) | (b ^ !a) = (a !== b)</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>discrete event simulator ⇒ performs actions (function that takes no params and returns <code class="language-plaintext highlighter-rouge">Unit</code>) specified by the user at the given moment</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Wires and basic gates should inherit from this</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Simulation</span> <span class="o">{</span>

	<span class="k">type</span> <span class="kt">Action</span> <span class="o">=</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>

	<span class="k">case</span> <span class="k">class</span> <span class="nc">Event</span><span class="o">(</span><span class="n">time</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">action</span><span class="k">:</span> <span class="kt">Action</span><span class="o">)</span>
	<span class="c1">// sorted list of events to perform</span>
	<span class="k">private</span> <span class="k">type</span> <span class="kt">Agenda</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Event</span><span class="o">]</span>

	<span class="k">private</span> <span class="k">var</span> <span class="n">agenda</span><span class="k">:</span> <span class="kt">Agenda</span> <span class="o">=</span> <span class="nc">List</span><span class="o">()</span>
	<span class="k">private</span> <span class="k">var</span> <span class="n">curtime</span> <span class="k">=</span> <span class="mi">0</span>

	<span class="k">def</span> <span class="nf">currentTime</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">curtime</span>

	<span class="k">def</span> <span class="nf">afterDelay</span><span class="o">(</span><span class="n">delay</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">block</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="k">val</span> <span class="nv">item</span> <span class="k">=</span> <span class="nc">Event</span><span class="o">(</span><span class="n">curtime</span> <span class="o">+</span> <span class="n">delay</span><span class="o">,</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">block</span><span class="o">)</span>
		<span class="n">agenda</span> <span class="k">=</span> <span class="nf">insert</span><span class="o">(</span><span class="n">agenda</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
	<span class="o">}</span>

	<span class="k">private</span> <span class="k">def</span> <span class="nf">insert</span><span class="o">(</span><span class="n">ag</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Event</span><span class="o">],</span> <span class="n">item</span><span class="k">:</span> <span class="kt">Event</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Event</span><span class="o">]</span> <span class="k">=</span> <span class="n">ag</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="n">first</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">if</span> <span class="nv">first</span><span class="o">.</span><span class="py">time</span> <span class="o">&lt;=</span> <span class="nv">item</span><span class="o">.</span><span class="py">time</span> <span class="k">=&gt;</span>
			<span class="n">first</span> <span class="o">::</span> <span class="nf">insert</span><span class="o">(</span><span class="n">rest</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
		<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
			<span class="n">item</span> <span class="o">::</span> <span class="n">ag</span>
	<span class="o">}</span>

	<span class="k">private</span> <span class="k">def</span> <span class="nf">loop</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">agenda</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="n">first</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span> <span class="o">{</span>
			<span class="n">agenda</span> <span class="k">=</span> <span class="n">rest</span>
			<span class="n">curtime</span> <span class="k">=</span> <span class="nv">first</span><span class="o">.</span><span class="py">time</span> <span class="c1">// doesn't really delay, just calculates new time</span>
			<span class="nv">first</span><span class="o">.</span><span class="py">action</span><span class="o">()</span>
			<span class="nf">loop</span><span class="o">()</span>
		<span class="o">}</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span>
	<span class="o">}</span>

	<span class="k">def</span> <span class="nf">run</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="nf">afterDelay</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="nf">println</span><span class="o">(</span><span class="s">"*** simulation started, time = "</span> <span class="o">+</span> <span class="n">currentTime</span> <span class="o">+</span> <span class="s">" ***"</span><span class="o">)</span>
		<span class="o">}</span>
		<span class="nf">loop</span><span class="o">()</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Gates</span> <span class="k">extends</span> <span class="nc">Simulation</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">InverterDelay</span><span class="k">:</span> <span class="kt">Int</span>
	<span class="k">def</span> <span class="nf">AndGateDelay</span><span class="k">:</span> <span class="kt">Int</span>
	<span class="k">def</span> <span class="nf">OrGateDelay</span><span class="k">:</span> <span class="kt">Int</span>

	<span class="k">class</span> <span class="nc">Wire</span> <span class="o">{</span>
		<span class="k">private</span> <span class="k">val</span> <span class="nv">sigVal</span> <span class="k">=</span> <span class="kc">false</span>
		<span class="k">private</span> <span class="k">var</span> <span class="n">actions</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Action</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>

		<span class="c1">// return the current value of the signal</span>
		<span class="k">def</span> <span class="nf">signal</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">sigVal</span>

		<span class="c1">// modify the value of the signal</span>
		<span class="k">def</span> <span class="nf">setSgnal</span><span class="o">(</span><span class="n">sig</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
			<span class="nf">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">sigVal</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">sigVal</span> <span class="k">=</span> <span class="n">s</span>
				<span class="n">actions</span> <span class="nf">foreach</span> <span class="o">(</span><span class="nf">_</span><span class="o">())</span> <span class="c1">// run each action</span>
			<span class="o">}</span>

		<span class="c1">// Performs the new action added immediately and</span>
		<span class="c1">// adds it to the list of actions performed each time the signal changes</span>
		<span class="k">def</span> <span class="nf">addAction</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Action</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
			<span class="n">actions</span> <span class="k">=</span> <span class="n">a</span> <span class="o">::</span> <span class="n">actions</span>
			<span class="nf">a</span><span class="o">()</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="c1">// We can then implement the basic gates like this</span>
	<span class="k">def</span> <span class="nf">inverter</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">invertAction</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
			<span class="k">val</span> <span class="nv">inputSig</span> <span class="k">=</span> <span class="nv">input</span><span class="o">.</span><span class="py">getSignal</span>
			<span class="nf">afterDelay</span><span class="o">(</span><span class="nc">InverterDelay</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// change is effective after a delay</span>
				<span class="n">ouput</span> <span class="n">setSignal</span> <span class="o">!</span><span class="n">inputSig</span> <span class="c1">// produce inverse signal on output wire</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="c1">// install inverse action on input wire so that inverse is performed</span>
		<span class="c1">// each time the signal on the input wire changes</span>
		<span class="n">input</span> <span class="n">addAction</span> <span class="n">invertAction</span>
	<span class="o">}</span>

	<span class="k">def</span> <span class="nf">andGate</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">andAction</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
			<span class="c1">// If we fetched signals from A, B after the delay</span>
			<span class="c1">// andGate computation would be as if it was instantaneous</span>
			<span class="k">val</span> <span class="nv">aSig</span> <span class="k">=</span> <span class="nv">a</span><span class="o">.</span><span class="py">getSignal</span>
			<span class="k">val</span> <span class="nv">bSig</span> <span class="k">=</span> <span class="nv">b</span><span class="o">.</span><span class="py">getSignal</span>
			<span class="nf">afterDelay</span><span class="o">(</span><span class="nc">AndGateDelay</span><span class="o">)</span> <span class="o">{</span> <span class="n">output</span> <span class="nf">setSignal</span> <span class="o">(</span><span class="n">aSig</span> <span class="o">&amp;</span> <span class="n">bSig</span><span class="o">)</span> <span class="o">}</span>
		<span class="o">}</span>
		<span class="n">a</span> <span class="n">addAction</span> <span class="n">andAction</span>
		<span class="n">b</span> <span class="n">addAction</span> <span class="n">andAction</span>
	<span class="o">}</span>

	<span class="k">def</span> <span class="nf">orGate</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">orAction</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
			<span class="k">val</span> <span class="nv">aSig</span> <span class="k">=</span> <span class="nv">a</span><span class="o">.</span><span class="py">getSignal</span>
			<span class="k">val</span> <span class="nv">bSig</span> <span class="k">=</span> <span class="nv">b</span><span class="o">.</span><span class="py">getSignal</span>
			<span class="nf">afterDelay</span><span class="o">(</span><span class="nc">OrGateDelay</span><span class="o">)</span> <span class="o">{</span> <span class="n">output</span> <span class="nf">setSignal</span> <span class="o">(</span><span class="n">aSig</span> <span class="o">|</span> <span class="n">bSig</span><span class="o">)</span> <span class="o">}</span>
		<span class="o">}</span>
		<span class="n">a</span> <span class="n">addAction</span> <span class="n">orAction</span>
		<span class="n">b</span> <span class="n">addAction</span> <span class="n">orAction</span>
	<span class="o">}</span>

	<span class="c1">// use probe to check signal of a wire</span>
	<span class="k">def</span> <span class="nf">probe</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wire</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">probeAction</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
			<span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$name $currentTime value = ${wire.getSignal}"</span><span class="o">)</span>
		<span class="o">}</span>
		<span class="n">wire</span> <span class="n">addAction</span> <span class="n">probeAction</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Parameters</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">InvertedDelay</span> <span class="k">=</span> <span class="mi">2</span>
	<span class="k">def</span> <span class="nf">AndGateDelay</span> <span class="k">=</span> <span class="mi">3</span>
	<span class="k">def</span> <span class="nf">OrGateDelay</span> <span class="k">=</span> <span class="mi">5</span>
<span class="o">}</span>

<span class="c1">// Create simulation object</span>
<span class="k">object</span> <span class="nc">sim</span> <span class="k">extends</span> <span class="nc">Circuits</span> <span class="k">with</span> <span class="nc">Parameters</span> <span class="o">{</span>
	<span class="k">import</span> <span class="nn">sim._</span>
	<span class="k">val</span> <span class="nv">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">carry</span><span class="o">,</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
	<span class="nf">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">carry</span><span class="o">)</span>
	<span class="nf">probe</span><span class="o">(</span><span class="s">"sum"</span><span class="o">,</span> <span class="n">sum</span><span class="o">)</span> <span class="c1">// sum = 0 at time 0</span>
	<span class="nf">probe</span><span class="o">(</span><span class="s">"carry"</span><span class="o">,</span> <span class="n">carry</span><span class="o">)</span> <span class="c1">// carry = 0 at time 0</span>

	<span class="n">a</span> <span class="n">setSignal</span> <span class="kc">true</span> <span class="c1">// simulation started</span>
	<span class="nf">run</span><span class="o">()</span> <span class="c1">// sum = 1 at time 8</span>

	<span class="c1">// We can also define OR in terms of AND and INV</span>
	<span class="c1">// a | b = !(!a &amp;&amp; !b)</span>
	<span class="k">def</span> <span class="nf">orGateAlt</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">{</span>
		<span class="kt">val</span> <span class="kt">notA</span><span class="o">,</span> <span class="kt">notB</span><span class="o">,</span> <span class="n">notOut</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
		<span class="nf">inverter</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">notA</span><span class="o">);</span> <span class="nf">inverter</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">notB</span><span class="o">)</span>
		<span class="nf">andGate</span><span class="o">(</span><span class="n">notA</span><span class="o">,</span> <span class="n">notB</span><span class="o">,</span> <span class="n">notOut</span><span class="o">)</span>
		<span class="nf">inverter</span><span class="o">(</span><span class="n">notOut</span><span class="o">,</span> <span class="n">output</span><span class="o">)</span>
	<span class="o">}</span>

	<span class="c1">// If we replace orGate with orGateAlt, we'd get the same final outputs</span>
	<span class="c1">// but we'd see oscillation events, and the timings will be different</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="week-5">Week 5</h1>

<p><strong>Observer Pattern</strong> ⇒ separating programs into:</p>

<ul>
  <li>models ⇒ holds data which it publishes to views</li>
  <li>views ⇒ subscribes to data from models</li>
  <li>controller ⇒ optional manager of views and models</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Publisher</span> <span class="o">{</span>
	<span class="k">var</span> <span class="n">subscribers</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Subscriber</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">()</span>

	<span class="k">def</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">subsriber</span><span class="k">:</span> <span class="kt">Subscriber</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
		<span class="n">subscribers</span> <span class="o">+=</span> <span class="n">subscriber</span>

	<span class="k">def</span> <span class="nf">unsubscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="k">:</span> <span class="kt">Subscriber</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
		<span class="n">subscribers</span> <span class="o">-=</span> <span class="n">subscriber</span>

	<span class="k">def</span> <span class="nf">publish</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
		<span class="nv">subscribers</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">handler</span><span class="o">(</span><span class="k">this</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Subscriber</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">handler</span><span class="o">(</span><span class="n">pub</span><span class="k">:</span> <span class="kt">Publisher</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s implement <code class="language-plaintext highlighter-rouge">BankAccount</code> as an Observer pattern.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BankAccount</span> <span class="k">extends</span> <span class="nc">Publisher</span> <span class="o">{</span>
	<span class="k">private</span> <span class="k">var</span> <span class="n">balance</span> <span class="k">=</span> <span class="mi">0</span>

	<span class="k">def</span> <span class="nf">currentBalance</span> <span class="k">=</span> <span class="n">balance</span>

	<span class="k">def</span> <span class="nf">deposit</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">balance</span> <span class="k">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="n">amount</span>
			<span class="nf">publish</span><span class="o">()</span>
		<span class="err">]</span>

	<span class="k">def</span> <span class="nf">withdraw</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">amount</span> <span class="o">&amp;&amp;</span> <span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">balance</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">balance</span> <span class="k">=</span> <span class="n">balance</span> <span class="o">-</span> <span class="n">amount</span>
			<span class="nf">publish</span><span class="o">()</span>
		<span class="o">}</span> <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"insufficient funds"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// knows the total balance of observed bank accounts</span>
<span class="k">class</span> <span class="nc">Consolidator</span><span class="o">(</span><span class="n">observed</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">BankAcconut</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Subscriber</span> <span class="o">{</span>

	<span class="nv">observed</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">subscribe</span><span class="o">(</span><span class="k">this</span><span class="o">))</span>
	<span class="k">private</span> <span class="k">var</span> <span class="n">total</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">_</span> <span class="c1">// uninitialized field</span>
	<span class="nf">compute</span><span class="o">()</span> <span class="c1">// computes total</span>

	<span class="k">private</span> <span class="k">def</span> <span class="nf">compute</span><span class="o">()</span> <span class="k">=</span>
		<span class="n">total</span> <span class="k">=</span> <span class="nv">observed</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">currentBalance</span><span class="o">).</span><span class="py">sum</span>

	<span class="c1">// recompute on each bank account balance change</span>
	<span class="k">def</span> <span class="nf">handler</span><span class="o">(</span><span class="n">pub</span><span class="k">:</span><span class="kt">Publisher</span><span class="o">)</span> <span class="k">=</span> <span class="nf">compute</span><span class="o">()</span>

	<span class="k">def</span> <span class="nf">totalBalance</span> <span class="k">=</span> <span class="n">total</span>
<span class="o">}</span>

<span class="c1">// use like this</span>
<span class="k">val</span> <span class="nv">a</span><span class="o">,</span> <span class="n">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BalnkAccount</span>
<span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Consolidator</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
<span class="nv">c</span><span class="o">.</span><span class="py">totalBalance</span> <span class="c1">// 0</span>
<span class="n">a</span> <span class="n">deposit</span> <span class="mi">20</span>
<span class="nv">c</span><span class="o">.</span><span class="py">totalBalance</span> <span class="c1">// 20</span>
</code></pre></div></div>

<p>Observer Pattern pros:</p>

<ul>
  <li>decouples views from states</li>
  <li>allows for a varying number of views of a single state</li>
  <li>simple to set up</li>
</ul>

<p>Observer Pattern cons:</p>

<ul>
  <li>forces imperative updates, since handlers are <code class="language-plaintext highlighter-rouge">Unit</code> typed</li>
  <li>many calls between Publishers and Subscribers, which increases complexity and causes concurrency problems</li>
  <li>views are tightly bound to states</li>
</ul>

<p>From Adobe’s 2008 study of their own desktop applications:</p>

<ul>
  <li>1/3 of all code is devoted to event handling (bulky!)</li>
  <li>1/2 of all bugs are in the event handling code (buggy!)</li>
</ul>

<h2 id="functional-reactive-programming">Functional Reactive Programming</h2>

<p>reactive programming ⇒ react to sequences of events that happen in time</p>

<p>functional reactive programming (FRP) ⇒ think of events as a function from time to some signal, and define reaction to events as a new signal function based on existing ones</p>

<p>As an example, consider a mouse movement event:</p>

<ul>
  <li>in an event based view, an event <code class="language-plaintext highlighter-rouge">MouseMoved(toPos: Position)</code> is fired</li>
  <li>in FRP, a signal <code class="language-plaintext highlighter-rouge">mousePosition: Signal[Position]</code> is defined that represents the current mouse position at any point in time</li>
</ul>

<p>FRP started in 1997 with the paper Functional Reactive Animation by Elliot and Paul Hudak. FRP systems and languages include: Fran Library, Flapjax, Elm, Bacon.js, React4J etc.</p>

<p>FRP is related to but distinct from Rx, which is an event streaming dataflow programming system.</p>

<p>Let’s now look at <code class="language-plaintext highlighter-rouge">frp.Signal</code>, which is a simplification of <code class="language-plaintext highlighter-rouge">Scala.react</code>.</p>

<p>Signals have 2 fundamental operations:</p>

<ol>
  <li>Obtain the value of the signal by <code class="language-plaintext highlighter-rouge">()</code> application</li>
  <li>Define a signal in terms of other signals using the <code class="language-plaintext highlighter-rouge">Signal</code> constructor.</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// is a mouse position within a given rectangle?</span>
<span class="k">def</span> <span class="nf">inRectangle</span><span class="o">(</span><span class="nc">LL</span><span class="k">:</span> <span class="kt">Position</span><span class="o">,</span> <span class="nc">UR</span><span class="k">:</span> <span class="kt">Position:</span> <span class="kt">Signal</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
	<span class="nc">Signal</span> <span class="o">{</span>
		<span class="k">val</span> <span class="nv">pos</span> <span class="k">=</span> <span class="nf">mousePosition</span><span class="o">()</span>
		<span class="nc">LL</span> <span class="o">&lt;=</span> <span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="nc">UR</span>
	<span class="o">}</span>

<span class="c1">// constant signal giving value 3</span>
<span class="k">val</span> <span class="nv">sig</span> <span class="k">=</span> <span class="nc">Signal</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Var</code> is a subclass of <code class="language-plaintext highlighter-rouge">Signal</code> that is mutable. However, it’s not like a mutable variable. If you update a signal, the signals upstream which depend on it automatically receive its update as well. However, you must manually update all variables which depend upon your changed mutable variable.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">sig</span> <span class="k">=</span> <span class="nc">Var</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="nv">sig</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span> <span class="c1">// redefines signal value from this point on</span>

<span class="c1">// In Scala, calls to update can be written as assignments</span>
<span class="nv">arr</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
	<span class="o">===</span> <span class="nf">arr</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="mi">0</span>

<span class="nv">sig</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
	<span class="o">===</span> <span class="nf">sig</span><span class="o">()</span> <span class="k">=</span> <span class="mi">5</span>
</code></pre></div></div>

<p>Let’s rewrite our <code class="language-plaintext highlighter-rouge">BankAccount</code> example using signals.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BankAccount</span> <span class="o">{</span>
	<span class="k">val</span> <span class="nv">balance</span> <span class="k">=</span> <span class="nc">Var</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

	<span class="k">def</span> <span class="nf">currentBalance</span> <span class="k">=</span> <span class="n">balance</span>

	<span class="k">def</span> <span class="nf">deposit</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">// `balance() = balance() + amount` would be a cyclic defintion</span>
			<span class="c1">// it defines balance as amount larger than itself at all times</span>
			<span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="nf">balance</span><span class="o">()</span>
			<span class="nf">balance</span><span class="o">()</span> <span class="k">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">amount</span>
		<span class="err">]</span>

	<span class="k">def</span> <span class="nf">withdraw</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">amount</span> <span class="o">&amp;&amp;</span> <span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">balance</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="nf">balance</span><span class="o">()</span>
			<span class="nf">balance</span><span class="o">()</span> <span class="k">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">amount</span>
		<span class="o">}</span> <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"insufficient funds"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// knows the total balance of observed bank accounts</span>
<span class="k">def</span> <span class="nf">consolidated</span><span class="o">(</span><span class="n">observed</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">BankAcconut</span><span class="o">])</span><span class="k">:</span> <span class="kt">Signal</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
	<span class="nc">Signal</span><span class="o">(</span><span class="nv">observed</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">balance</span><span class="o">()).</span><span class="py">sum</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">exchangeRate</span> <span class="k">=</span> <span class="nc">Signal</span><span class="o">(</span><span class="mf">5.00</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">inDollar</span> <span class="k">=</span> <span class="nc">Signal</span><span class="o">(</span><span class="nf">c</span><span class="o">()</span> <span class="o">*</span> <span class="nf">exchangeRate</span><span class="o">())</span>

<span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BankAccount</span><span class="o">()</span>
<span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BankAccount</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="nf">consolidated</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
<span class="nf">c</span><span class="o">()</span> <span class="c1">// 0</span>
<span class="n">a</span> <span class="n">deposit</span> <span class="mi">20</span>
<span class="nf">c</span><span class="o">()</span> <span class="c1">// 20</span>

<span class="nf">inDollar</span><span class="o">()</span> <span class="c1">// 100.00</span>
</code></pre></div></div>

<p>This solution is shorter and cleaner than the Observer model we previously saw, since there are fewer state updates.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1</span>
<span class="k">val</span> <span class="nv">num</span> <span class="k">=</span> <span class="nc">Var</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">twice</span> <span class="k">=</span> <span class="nc">Signal</span><span class="o">(</span><span class="nf">num</span><span class="o">()</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="nf">num</span><span class="o">()</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// call update function</span>
<span class="nf">twice</span><span class="o">()</span> <span class="c1">// 4</span>

<span class="c1">// 2</span>
<span class="k">val</span> <span class="nv">num</span> <span class="k">=</span> <span class="nc">Var</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">twice</span> <span class="k">=</span> <span class="nc">Signal</span><span class="o">(</span><span class="nf">num</span><span class="o">()</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">num</span> <span class="k">=</span> <span class="nc">Var</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="c1">// define a new signal num!</span>
<span class="nf">twice</span><span class="o">()</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p>Let’s now see a simple implementation of <code class="language-plaintext highlighter-rouge">Signal</code> and <code class="language-plaintext highlighter-rouge">Var</code>.</p>

<p>Each signal maintains:</p>

<ul>
  <li>its current values</li>
  <li>the current expression that defines the signal value</li>
  <li>a set of observer signals that depend on its value</li>
</ul>

<p>We maintain the set of observer signals by:</p>

<ol>
  <li>Whenever <code class="language-plaintext highlighter-rouge">sig()</code> is called, add the caller to the list of observers. For now, we can track the caller in a global stack variable.</li>
  <li>When <code class="language-plaintext highlighter-rouge">sig</code> has its value changed, all observers are re-evaluated and the set of observers is cleared. We can do this because if a re-evaluated observer still depends on <code class="language-plaintext highlighter-rouge">sig</code>, it will be added to the list of observers again when it calls <code class="language-plaintext highlighter-rouge">sig()</code>.</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StackableVariable</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">init</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">private</span> <span class="k">var</span> <span class="n">values</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">init</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">value</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="nv">values</span><span class="o">.</span><span class="py">head</span>
	<span class="k">def</span> <span class="nf">withValue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">newValue</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">op</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span> <span class="o">{</span>
		<span class="c1">// put the new value at the top of the list</span>
		<span class="n">values</span> <span class="k">=</span> <span class="n">newValue</span> <span class="o">::</span> <span class="n">values</span>
		<span class="c1">// after the operation is finished, pop the new value from the list</span>
		<span class="k">try</span> <span class="n">op</span> <span class="k">finally</span> <span class="n">values</span> <span class="k">=</span> <span class="nv">value</span><span class="o">.</span><span class="py">tail</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// global caller variable</span>
<span class="k">val</span> <span class="nv">caller</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StackableVar</span><span class="o">(</span><span class="n">initialSig</span><span class="o">)</span>
<span class="c1">// while expr evaluates, caller = otherSig</span>
<span class="nv">caller</span><span class="o">.</span><span class="py">withValue</span><span class="o">(</span><span class="n">otherSig</span><span class="o">)</span> <span class="o">{</span> <span class="n">expr</span> <span class="o">}</span>

<span class="c1">// Initially, there is no caller which we represent by NoSignal</span>
<span class="c1">// We can pass ??? as unimplemented in Scala</span>
<span class="k">object</span> <span class="nc">NoSignal</span> <span class="k">extends</span> <span class="nc">Signal</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">](???)</span> <span class="o">{</span>
	<span class="k">override</span> <span class="k">def</span> <span class="nf">computeValue</span><span class="o">()</span> <span class="k">=</span> <span class="o">()</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Signal</span> <span class="o">{</span>
	<span class="c1">// use Scala's thread safe version of StackableVariable</span>
	<span class="k">private</span> <span class="k">val</span> <span class="nv">caller</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DynamicVariable</span><span class="o">[</span><span class="kt">Signal</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="nc">NoSignal</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">expr</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Signal</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Signal</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">expr</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">import</span> <span class="nn">Signal._</span>
	<span class="k">private</span> <span class="k">var</span> <span class="n">myExpr</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="k">_</span>
	<span class="k">private</span> <span class="k">var</span> <span class="n">myValue</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="k">_</span>
	<span class="k">private</span> <span class="k">var</span> <span class="n">observers</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Signal</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">()</span>
	<span class="c1">// initialize myExpr and myValue using update call</span>
	<span class="nf">update</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span>

	<span class="k">protected</span> <span class="k">def</span> <span class="nf">update</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="n">myExpr</span> <span class="k">=</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">expr</span>
		<span class="nf">computeValue</span><span class="o">()</span>
	<span class="o">}</span>

	<span class="k">protected</span> <span class="k">def</span> <span class="nf">computeValue</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
		<span class="k">val</span> <span class="nv">newValue</span> <span class="k">=</span> <span class="nv">caller</span><span class="o">.</span><span class="py">withValue</span><span class="o">(</span><span class="k">this</span><span class="o">)(</span><span class="nf">myExpr</span><span class="o">())</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">myValue</span> <span class="o">!=</span> <span class="n">newValue</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">myValue</span> <span class="k">=</span> <span class="n">newValue</span>
			<span class="k">val</span> <span class="nv">obs</span> <span class="k">=</span> <span class="n">observers</span>
			<span class="n">observers</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">()</span>
			<span class="nv">obs</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">computeValue</span><span class="o">())</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="k">def</span> <span class="nf">apply</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
		<span class="n">observers</span> <span class="o">+=</span> <span class="nv">caller</span><span class="o">.</span><span class="py">value</span>
		<span class="nf">assert</span><span class="o">(</span>
			<span class="o">!</span><span class="nv">caller</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">observers</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="k">this</span><span class="o">),</span>
			<span class="s">"cyclic signal definition"</span>
		<span class="o">)</span>
		<span class="n">myValue</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Var</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">expr</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Signal</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">expr</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// expose protected method from parent</span>
	<span class="k">override</span> <span class="k">def</span> <span class="nf">update</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nv">super</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Var</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">expr</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Var</span><span class="o">(</span><span class="n">expr</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>However, our implementation of <code class="language-plaintext highlighter-rouge">caller</code> as global state is problematic when you consider concurrent programs. We could try to use synchronization, but that blocks threads, can be slow, and can lead to deadlocks.</p>

<p>Instead we should use thread local state (<code class="language-plaintext highlighter-rouge">scala.util.DynamicVariable</code>), meaning that each thread accesses a separate copy of a variable. However, it still comes with disadvantages:</p>

<ul>
  <li>imperative nature produces hidden dependencies which are hard to manage</li>
  <li>implementation on JDK involves a global hash table lookup, which can be a performance problem</li>
  <li>doesn’t play well when threads are multiplexed between several tasks</li>
</ul>

<p>A cleaner solution involves passing implicit parameter, which is purely functional. However, it requires more boilerplate than the thread-local version.</p>

<p>We’ve only looked at discrete event signals so far, but for continuous signals, we need to use sampling. Continuous signals are outside the scope of this course.</p>
</div><section class="article__sharing d-print-none"></section><div class="d-print-none"><footer class="article__footer"><meta itemprop="dateModified" content="2020-09-02T00:00:00+00:00"><!-- start custom article footer snippet -->

<!-- end custom article footer snippet -->
<div class="article__subscribe"><div class="subscribe"><i class="fas fa-rss"></i> <a type="application/rss+xml" href="notes/feed.xml">Subscribe</a></div>
</div><div class="article__license"><div class="license">
    <p>This work is licensed under a <a itemprop="license" rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">Attribution-NonCommercial 4.0 International</a> license.
      <a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">
        <img alt="Attribution-NonCommercial 4.0 International" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" />
      </a>
    </p>
  </div></div></footer>
<div class="article__section-navigator clearfix"><div class="previous"><span>PREVIOUS</span><a href="notes/2020/09/02/progfun.html">Functional Programming Principles in Scala</a></div></div></div>

</div>

<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    $(function() {
      var $this ,$scroll;
      var $articleContent = $('.js-article-content');
      var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
      var scroll = hasSidebar ? '.js-page-main' : 'html, body';
      $scroll = $(scroll);

      $articleContent.find('.highlight').each(function() {
        $this = $(this);
        $this.attr('data-lang', $this.find('code').attr('data-lang'));
      });
      $articleContent.find('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]').each(function() {
        $this = $(this);
        $this.append($('<a class="anchor d-print-none" aria-hidden="true"></a>').html('<i class="fas fa-anchor"></i>'));
      });
      $articleContent.on('click', '.anchor', function() {
        $scroll.scrollToAnchor('#' + $(this).parent().attr('id'), 400);
      });
    });
  });
})();
</script>
</div><section class="page__comments d-print-none"></section></article><!-- start custom main bottom snippet -->

<!-- end custom main bottom snippet -->
</div>
            </div></div></div><div class="page__footer d-print-none">
<footer class="footer py-4 js-page-footer">
  <div class="main"><div itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ivy Zhou"><meta itemprop="url" content="notes/"><meta itemprop="description" content="an uneasy soul"><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"><li title="Follow me on Medium.">
        <a class="button button--circle medium-button" itemprop="sameAs" href="https://medium.com/ivyzhou" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M834.7 279.8l61.3-58.9V208H683.7L532.4 586.4 360.3 208H137.7v12.9l71.6 86.6c7 6.4 10.6 15.8 9.7 25.2V673c2.2 12.3-1.7 24.8-10.3 33.7L128 805v12.7h228.6v-12.9l-80.6-98a39.99 39.99 0 0 1-11.1-33.7V378.7l200.7 439.2h23.3l172.6-439.2v349.9c0 9.2 0 11.1-6 17.2l-62.1 60.3V819h301.2v-12.9l-59.9-58.9c-5.2-4-7.9-10.7-6.8-17.2V297a18.1 18.1 0 0 1 6.8-17.2z"></path>
</svg>
</div>
        </a>
      </li><li title="Follow me on Linkedin.">
        <a class="button button--circle linkedin-button" itemprop="sameAs" href="https://www.linkedin.com/in/zhouivy" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M260.096 155.648c0 27.307008-9.899008 50.516992-29.696 69.632-19.796992 19.115008-45.396992 28.672-76.8 28.672-30.036992 0-54.612992-9.556992-73.728-28.672-19.115008-19.115008-28.672-42.324992-28.672-69.632 0-28.672 9.556992-52.224 28.672-70.656 19.115008-18.432 44.372992-27.648 75.776-27.648 31.403008 0 56.32 9.216 74.752 27.648 18.432 18.432 28.331008 41.984 29.696 70.656 0 0 0 0 0 0m-202.752 808.96c0 0 0-632.832 0-632.832 0 0 196.608 0 196.608 0 0 0 0 632.832 0 632.832 0 0-196.608 0-196.608 0 0 0 0 0 0 0m313.344-430.08c0-58.708992-1.364992-126.292992-4.096-202.752 0 0 169.984 0 169.984 0 0 0 10.24 88.064 10.24 88.064 0 0 4.096 0 4.096 0 40.96-68.267008 105.812992-102.4 194.56-102.4 68.267008 0 123.220992 22.868992 164.864 68.608 41.643008 45.739008 62.464 113.664 62.464 203.776 0 0 0 374.784 0 374.784 0 0-196.608 0-196.608 0 0 0 0-350.208 0-350.208 0-91.476992-33.451008-137.216-100.352-137.216-47.787008 0-81.236992 24.576-100.352 73.728-4.096 8.192-6.144 24.576-6.144 49.152 0 0 0 364.544 0 364.544 0 0-198.656 0-198.656 0 0 0 0-430.08 0-430.08 0 0 0 0 0 0" />
</svg>
</div>
        </a>
      </li><li title="Follow me on Github.">
        <a class="button button--circle github-button" itemprop="sameAs" href="https://github.com/ivy-zhou" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path class="svgpath" data-index="path_0" fill="#272636" d="M0 525.2c0 223.6 143.3 413.7 343 483.5 26.9 6.8 22.8-12.4 22.8-25.4l0-88.7c-155.3 18.2-161.5-84.6-172-101.7-21.1-36-70.8-45.2-56-62.3 35.4-18.2 71.4 4.6 113.1 66.3 30.2 44.7 89.1 37.2 119 29.7 6.5-26.9 20.5-50.9 39.7-69.6C248.8 728.2 181.7 630 181.7 513.2c0-56.6 18.7-108.7 55.3-150.7-23.3-69.3 2.2-128.5 5.6-137.3 66.5-6 135.5 47.6 140.9 51.8 37.8-10.2 80.9-15.6 129.1-15.6 48.5 0 91.8 5.6 129.8 15.9 12.9-9.8 77-55.8 138.8-50.2 3.3 8.8 28.2 66.7 6.3 135 37.1 42.1 56 94.6 56 151.4 0 117-67.5 215.3-228.8 243.7 26.9 26.6 43.6 63.4 43.6 104.2l0 128.8c0.9 10.3 0 20.5 17.2 20.5C878.1 942.4 1024 750.9 1024 525.3c0-282.9-229.3-512-512-512C229.1 13.2 0 242.3 0 525.2L0 525.2z" />
</svg>
</div>
        </a>
      </li></ul>
</div>
</div>
    </div><div class="site-info mt-2">
      <div>© Sentences 2020,
        Powered by <a title="Jekyll is a simple, blog-aware, static site generator." href="http://jekyllrb.com/">Jekyll</a> & <a
        title="TeXt is a super customizable Jekyll theme." href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt Theme</a>.
      </div>
    </div>
  </div>
</footer>
</div></div>
    </div><script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $body = $('body'), $window = $(window);
    var $pageRoot = $('.js-page-root'), $pageMain = $('.js-page-main');
    var activeCount = 0;
    function modal(options) {
      var $root = this, visible, onChange, hideWhenWindowScroll = false;
      var scrollTop;
      function setOptions(options) {
        var _options = options || {};
        visible = _options.initialVisible === undefined ? false : show;
        onChange = _options.onChange;
        hideWhenWindowScroll = _options.hideWhenWindowScroll;
      }
      function init() {
        setState(visible);
      }
      function setState(isShow) {
        if (isShow === visible) {
          return;
        }
        visible = isShow;
        if (visible) {
          activeCount++;
          scrollTop = $(window).scrollTop() || $pageMain.scrollTop();
          $root.addClass('modal--show');
          $pageMain.scrollTop(scrollTop);
          activeCount === 1 && ($pageRoot.addClass('show-modal'), $body.addClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.on('scroll', hide);
          $window.on('keyup', handleKeyup);
        } else {
          activeCount > 0 && activeCount--;
          $root.removeClass('modal--show');
          $window.scrollTop(scrollTop);
          activeCount === 0 && ($pageRoot.removeClass('show-modal'), $body.removeClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.off('scroll', hide);
          $window.off('keyup', handleKeyup);
        }
        onChange && onChange(visible);
      }
      function show() {
        setState(true);
      }
      function hide() {
        setState(false);
      }
      function handleKeyup(e) {
        // Char Code: 27  ESC
        if (e.which ===  27) {
          hide();
        }
      }
      setOptions(options);
      init();
      return {
        show: show,
        hide: hide,
        $el: $root
      };
    }
    $.fn.modal = modal;
  });
})();
</script><div class="modal modal--overflow page__search-modal d-print-none js-page-search-modal"><script>
(function () {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    // search panel
    var search = (window.search || (window.search = {}));
    var useDefaultSearchBox = window.useDefaultSearchBox === undefined ?
      true : window.useDefaultSearchBox ;

    var $searchModal = $('.js-page-search-modal');
    var $searchToggle = $('.js-search-toggle');
    var searchModal = $searchModal.modal({ onChange: handleModalChange, hideWhenWindowScroll: true });
    var modalVisible = false;
    search.searchModal = searchModal;

    var $searchBox = null;
    var $searchInput = null;
    var $searchClear = null;

    function getModalVisible() {
      return modalVisible;
    }
    search.getModalVisible = getModalVisible;

    function handleModalChange(visible) {
      modalVisible = visible;
      if (visible) {
        search.onShow && search.onShow();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].focus();
      } else {
        search.onShow && search.onHide();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].blur();
        setTimeout(function() {
          useDefaultSearchBox && ($searchInput.val(''), $searchBox.removeClass('not-empty'));
          search.clear && search.clear();
          window.pageAsideAffix && window.pageAsideAffix.refresh();
        }, 400);
      }
    }

    $searchToggle.on('click', function() {
      modalVisible ? searchModal.hide() : searchModal.show();
    });
    // Char Code: 83  S, 191 /
    $(window).on('keyup', function(e) {
      if (!modalVisible && !window.isFormElement(e.target || e.srcElement) && (e.which === 83 || e.which === 191)) {
        modalVisible || searchModal.show();
      }
    });

    if (useDefaultSearchBox) {
      $searchBox = $('.js-search-box');
      $searchInput = $searchBox.children('input');
      $searchClear = $searchBox.children('.js-icon-clear');
      search.getSearchInput = function() {
        return $searchInput.get(0);
      };
      search.getVal = function() {
        return $searchInput.val();
      };
      search.setVal = function(val) {
        $searchInput.val(val);
      };

      $searchInput.on('focus', function() {
        $(this).addClass('focus');
      });
      $searchInput.on('blur', function() {
        $(this).removeClass('focus');
      });
      $searchInput.on('input', window.throttle(function() {
        var val = $(this).val();
        if (val === '' || typeof val !== 'string') {
          search.clear && search.clear();
        } else {
          $searchBox.addClass('not-empty');
          search.onInputNotEmpty && search.onInputNotEmpty(val);
        }
      }, 400));
      $searchClear.on('click', function() {
        $searchInput.val(''); $searchBox.removeClass('not-empty');
        search.clear && search.clear();
      });
    }
  });
})();
</script><div class="search search--dark">
  <div class="main">
    <div class="search__header">Search</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--theme-dark button--pill search__cancel js-search-toggle">
        Cancel</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>
<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var search = (window.search || (window.search = {}));
  var searchData = window.TEXT_SEARCH_DATA || {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) { return null; }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function clear() {
    $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }
  function onInputNotEmpty(val) {
    $result.html(render(searchByQuery(val)));
    $resultItems = $('.search-result__item'); activeIndex = 0;
    $resultItems.eq(0).addClass('active');
  }

  search.clear = clear;
  search.onInputNotEmpty = onInputNotEmpty;

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  // Char Code: 13  Enter, 37  ⬅, 38  ⬆, 39  ➡, 40  ⬇
  $(window).on('keyup', function(e) {
    var modalVisible = search.getModalVisible && search.getModalVisible();
    if (modalVisible) {
      if (e.which === 38) {
        modalVisible && moveActiveIndex('up');
      } else if (e.which === 40) {
        modalVisible && moveActiveIndex('down');
      } else if (e.which === 13) {
        modalVisible && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });
});
</script>
</div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function affix(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroll,
        offsetBottom = 0, scrollTarget = window, scroll = window.document, disabled = false, isOverallScroller = true,
        rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop,
        hasInit = false, curState;

      function setOptions(options) {
        var _options = options || {};
        _options.offsetBottom && (offsetBottom = _options.offsetBottom);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroll && (scroll = _options.scroll);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $scrollTarget = $(scrollTarget);
        isOverallScroller = window.isOverallScroller($scrollTarget[0]);
        $scroll = $(scroll);
      }
      function preCalc() {
        top();
        rootHeight = $root.outerHeight();
        rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
        rootLeft = $root.offset().left;
      }
      function calc(needPreCalc) {
        needPreCalc && preCalc();
        scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
        rootBottomTop = scrollBottom - rootTop;
      }
      function top() {
        if (curState !== 'top') {
          $root.removeClass('fixed').css({
            left: 0,
            top: 0
          });
          curState = 'top';
        }
      }
      function fixed() {
        if (curState !== 'fixed') {
          $root.addClass('fixed').css({
            left: rootLeft + 'px',
            top: 0
          });
          curState = 'fixed';
        }
      }
      function bottom() {
        if (curState !== 'bottom') {
          $root.removeClass('fixed').css({
            left: 0,
            top: rootBottomTop + 'px'
          });
          curState = 'bottom';
        }
      }
      function setState() {
        var scrollTop = $scrollTarget.scrollTop();
        if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
          fixed();
        } else if (scrollTop < rootTop) {
          top();
        } else {
          bottom();
        }
      }
      function init() {
        if(!hasInit) {
          var interval, timeout;
          calc(true); setState();
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState();
          });
          $window.on('resize', function() {
            disabled || (calc(true), setState());
          });
          hasInit = true;
        }
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true, { animation: false }); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function toc(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroller, $tocUl = $('<ul class="toc toc--ellipsis"></ul>'), $tocLi, $headings, $activeLast, $activeCur,
        selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false,
        headingsPos, scrolling = false, hasRendered = false, hasInit = false;

      function setOptions(options) {
        var _options = options || {};
        _options.selectors && (selectors = _options.selectors);
        _options.container && (container = _options.container);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroller && (scroller = _options.scroller);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $headings = $(container).find(selectors).filter('[id]');
        $scrollTarget = $(scrollTarget);
        $scroller = $(scroller);
      }
      function calc() {
        headingsPos = [];
        $headings.each(function() {
          headingsPos.push(Math.floor($(this).position().top));
        });
      }
      function setState(element, disabled) {
        var scrollTop = $scrollTarget.scrollTop(), i;
        if (disabled || !headingsPos || headingsPos.length < 1) { return; }
        if (element) {
          $activeCur = element;
        } else {
          for (i = 0; i < headingsPos.length; i++) {
            if (scrollTop >= headingsPos[i]) {
              $activeCur = $tocLi.eq(i);
            } else {
              $activeCur || ($activeCur = $tocLi.eq(i));
              break;
            }
          }
        }
        $activeLast && $activeLast.removeClass('active');
        ($activeLast = $activeCur).addClass('active');
      }
      function render() {
        if(!hasRendered) {
          $root.append($tocUl);
          $headings.each(function() {
            var $this = $(this);
            $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
              .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
          });
          $tocLi = $tocUl.children('li');
          $tocUl.on('click', 'a', function(e) {
            e.preventDefault();
            var $this = $(this);
            scrolling = true;
            setState($this.parent());
            $scroller.scrollToAnchor($this.attr('href'), 400, function() {
              scrolling = false;
            });
          });
        }
        hasRendered = true;
      }
      function init() {
        var interval, timeout;
        if(!hasInit) {
          render(); calc(); setState(null, scrolling);
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState(null, scrolling);
          });
          $window.on('resize', window.throttle(function() {
            if (!disabled) {
              render(); calc(); setState(null, scrolling);
            }
          }, 100));
        }
        hasInit = true;
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();
/*(function () {

})();*/
</script><script>
  /* toc must before affix, since affix need to konw toc' height. */(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  var TOC_SELECTOR = window.TEXT_VARIABLES.site.toc.selectors;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window);
    var $articleContent = $('.js-article-content');
    var $tocRoot = $('.js-toc-root'), $col2 = $('.js-col-aside');
    var toc;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
    var hasToc = $articleContent.find(TOC_SELECTOR).length > 0;

    function disabled() {
      return $col2.css('display') === 'none' || !hasToc;
    }

    tocDisabled = disabled();

    toc = $tocRoot.toc({
      selectors: TOC_SELECTOR,
      container: $articleContent,
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      tocDisabled = disabled();
      toc && toc.setOptions({
        disabled: tocDisabled
      });
    }, 100));

  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $pageFooter = $('.js-page-footer');
    var $pageAside = $('.js-page-aside');
    var affix;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');

    affix = $pageAside.affix({
      offsetBottom: $pageFooter.outerHeight(),
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      scroll: hasSidebar ? $('.js-page-main').children() : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      affix && affix.setOptions({
        disabled: tocDisabled
      });
    }, 100));

    window.pageAsideAffix = affix;
  });
})();
</script><script>
  window.Lazyload.js(['https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js', 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js'], function() {
    var $canvas = null, $this = null, _ctx = null, _text = '';
    $('.language-chart').each(function(){
      $this = $(this);
      $canvas = $('<canvas></canvas>');
      _text = $this.text();
      $this.text('').append($canvas);
      _ctx = $canvas.get(0).getContext('2d');
      (_ctx && _text) && (new Chart(_ctx, JSON.parse(_text)) && $this.attr('data-processed', true));
    });
  });
</script>
<script type="text/x-mathjax-config">
	var _config = { tex2jax: {
		inlineMath: [['$','$'], ['\\(','\\)']]
	}};MathJax.Hub.Config(_config);
</script>
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  window.Lazyload.js('https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js', function() {
    mermaid.initialize({
      startOnLoad: true
    });
    mermaid.init(undefined, '.language-mermaid');
  });
</script>

    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();
</script>
  </body>
</html>


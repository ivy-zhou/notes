<!DOCTYPE html><html lang="en">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>Functional Programming Principles in Scala - Sentences</title>

<meta name="description" content="Functional Programming Principles in Scala | CourseraWeek 1Main programming paradigms:  imperative programming â‡’ instruction sequences for a Von Neumann comp...">
<link rel="canonical" href="/notes/2020/09/02/progfun.html"><link rel="alternate" type="application/rss+xml" title="Sentences" href="/notes/feed.xml"><!-- start favicons snippet, use https://realfavicongenerator.net/ --><link rel="apple-touch-icon" sizes="180x180" href="/notes/assets/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/notes/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/notes/assets/favicon-16x16.png"><link rel="manifest" href="/notes/assets/site.webmanifest"><link rel="mask-icon" href="/notes/assets/safari-pinned-tab.svg" color="#fc4d50"><link rel="shortcut icon" href="/notes/assets/favicon.ico">

<meta name="msapplication-TileColor" content="#ffc40d"><meta name="msapplication-config" content="/notes/assets/browserconfig.xml">

<meta name="theme-color" content="#ffffff">
<!-- end favicons snippet -->
<link rel="stylesheet" href="/notes/assets/css/main.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" ><!-- start custom head snippets -->

<!-- end custom head snippets -->
<script>(function() {
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };

  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  };

  window.isOverallScroller = function(node) {
    return node === document.documentElement || node === document.body || node === window;
  };

  window.isFormElement = function(node) {
    var tagName = node.tagName;
    return tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA';
  };

  window.pageLoad = (function () {
    var loaded = false, cbs = [];
    window.addEventListener('load', function () {
      var i;
      loaded = true;
      if (cbs.length > 0) {
        for (i = 0; i < cbs.length; i++) {
          cbs[i]();
        }
      }
    });
    return {
      then: function(cb) {
        cb && (loaded ? cb() : (cbs.push(cb)));
      }
    };
  })();
})();
(function() {
  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };
})();
(function() {
  var Set = (function() {
    var add = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (data[i] === item) {
          return;
        }
      }
      this.size ++;
      data.push(item);
      return data;
    };

    var Set = function(data) {
      this.size = 0;
      this._data = [];
      var i;
      if (data.length > 0) {
        for (i = 0; i < data.length; i++) {
          add.call(this, data[i]);
        }
      }
    };
    Set.prototype.add = add;
    Set.prototype.get = function(index) { return this._data[index]; };
    Set.prototype.has = function(item) {
      var i, data = this._data;
      for (i = 0; i < data.length; i++) {
        if (this.get(i) === item) {
          return true;
        }
      }
      return false;
    };
    Set.prototype.is = function(map) {
      if (map._data.length !== this._data.length) { return false; }
      var i, j, flag, tData = this._data, mData = map._data;
      for (i = 0; i < tData.length; i++) {
        for (flag = false, j = 0; j < mData.length; j++) {
          if (tData[i] === mData[j]) {
            flag = true;
            break;
          }
        }
        if (!flag) { return false; }
      }
      return true;
    };
    Set.prototype.values = function() {
      return this._data;
    };
    return Set;
  })();

  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    };
    var end = function(type, url) {
      var s, q, qi, cbs, i, j, cur, val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j];
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, q, qi, node, i, cur,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  };
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);
})();
</script><script>
  (function() {
    var TEXT_VARIABLES = {
      version: '2.2.6',
      sources: {
        font_awesome: 'https://use.fontawesome.com/releases/v5.0.13/css/all.css',
        jquery: 'https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js',
        leancloud_js_sdk: '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js',
        chart: 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js',
        gitalk: {
          js: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.js',
          css: 'https://cdn.bootcss.com/gitalk/1.2.2/gitalk.min.css'
        },
        valine: 'https://unpkg.com/valine/dist/Valine.min.js',
        mathjax: 'https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML',
        mermaid: 'https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js'
      },
      site: {
        toc: {
          selectors: 'h1,h2,h3'
        }
      },
      paths: {
        search_js: '/notes/assets/search.js'
      }
    };
    window.TEXT_VARIABLES = TEXT_VARIABLES;
  })();
</script>
</head>
  <body>
    <div class="root" data-is-touch="false">
      <div class="layout--page js-page-root"><div class="page__main js-page-main page__viewport has-aside cell cell--auto">

      <div class="page__main-inner"><div class="page__header d-print-none"><header class="header"><div class="main">
      <div class="header__title">
        <div class="header__brand"><?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20010904//EN"
 "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg version="1.0" xmlns="http://www.w3.org/2000/svg"
 width="512.000000pt" height="512.000000pt" viewBox="0 0 512.000000 512.000000"
 preserveAspectRatio="xMidYMid meet">
<metadata>
Created by potrace 1.11, written by Peter Selinger 2001-2013
</metadata>
<g transform="translate(0.000000,512.000000) scale(0.100000,-0.100000)"
fill="#000000" stroke="none">
<path d="M219 5026 c-52 -18 -91 -60 -104 -113 -16 -62 -8 -179 19 -288 14
-56 21 -78 38 -129 11 -32 21 -63 22 -70 2 -6 15 -38 30 -71 16 -33 29 -66 29
-72 0 -7 4 -13 9 -13 4 0 8 -9 8 -20 0 -11 3 -20 8 -20 4 0 18 -21 32 -47 13
-27 27 -50 30 -53 4 -3 9 -12 13 -20 9 -19 28 -48 49 -74 9 -12 32 -41 51 -65
l35 -44 -64 -65 c-35 -36 -66 -73 -69 -84 -4 -10 -10 -18 -14 -18 -9 0 -71
-97 -71 -111 0 -5 -5 -9 -11 -9 -5 0 -8 -4 -4 -9 3 -5 1 -12 -5 -16 -20 -12
-113 -229 -103 -239 4 -3 2 -6 -4 -6 -9 0 -17 -24 -27 -80 -1 -3 -5 -10 -9
-16 -3 -7 -9 -29 -13 -50 -3 -22 -9 -46 -14 -54 -4 -8 -10 -31 -14 -50 -3 -19
-8 -46 -11 -60 -3 -13 -7 -42 -10 -65 -3 -22 -8 -47 -10 -55 -2 -8 -7 -46 -11
-85 -3 -38 -8 -73 -10 -76 -2 -4 -7 -86 -10 -182 l-7 -175 44 5 c24 2 52 5 62
6 9 1 17 4 17 7 0 4 6 7 13 7 11 1 24 3 95 19 15 4 34 8 42 9 8 1 22 5 31 9 8
4 29 8 45 9 16 1 35 8 42 15 7 6 22 12 31 12 10 0 36 6 57 13 22 8 52 17 67
21 26 6 28 5 27 -21 -1 -15 -1 -32 0 -38 1 -5 1 -44 0 -85 -1 -41 -2 -92 -3
-112 0 -21 2 -40 4 -43 3 -2 2 -28 -1 -57 -5 -46 -13 -60 -53 -103 -66 -69
-68 -72 -120 -146 -26 -37 -47 -71 -47 -77 0 -6 -4 -12 -8 -14 -8 -3 -95 -173
-93 -183 1 -3 -6 -19 -14 -35 -9 -17 -13 -30 -10 -30 3 0 -1 -13 -10 -30 -8
-16 -15 -32 -15 -35 0 -3 0 -6 -1 -7 0 -2 -2 -11 -5 -20 -4 -19 -6 -27 -18
-69 -4 -14 -9 -41 -11 -60 -2 -19 -4 -34 -5 -34 -1 0 -4 -16 -6 -35 -7 -54
-10 -320 -4 -320 3 0 5 -17 4 -38 0 -20 2 -41 5 -47 6 -11 10 -28 13 -62 1
-13 5 -23 9 -23 3 0 6 -7 6 -15 0 -20 25 -98 35 -110 4 -5 8 -17 8 -27 0 -10
4 -18 9 -18 5 0 11 -10 15 -22 3 -13 16 -39 28 -58 12 -19 22 -37 23 -40 1
-14 67 -93 130 -156 65 -65 151 -134 200 -160 39 -20 70 -39 75 -45 3 -3 47
-22 99 -43 131 -53 278 -94 401 -111 25 -4 65 -10 90 -13 59 -9 2448 -9 2521
0 143 17 319 57 419 95 8 3 20 7 25 8 6 2 42 17 80 35 39 18 73 32 78 32 4 -1
7 2 7 7 0 5 10 13 23 16 12 4 32 17 45 28 12 11 22 16 22 11 0 -5 4 -4 8 2 4
5 25 23 47 39 55 39 207 195 225 231 8 16 18 31 22 34 10 8 63 114 60 123 -1
4 3 7 8 7 5 0 9 3 8 8 -2 7 21 80 31 97 3 6 6 15 8 20 5 24 13 62 17 83 3 12
8 27 11 32 3 6 1 10 -6 10 -8 0 -8 4 1 15 14 17 19 268 7 360 -11 88 -18 130
-24 145 -3 8 -6 18 -5 22 1 4 -8 35 -19 70 -12 35 -21 69 -22 76 0 6 -4 12 -9
12 -4 0 -7 3 -6 7 3 17 -15 63 -25 63 -6 0 -8 3 -4 6 8 8 -77 167 -131 244
-59 83 -58 81 -119 147 l-52 56 1 203 0 202 82 -25 c44 -13 88 -27 96 -30 17
-7 173 -47 225 -57 6 -1 19 -5 30 -9 11 -3 37 -8 57 -11 21 -3 41 -6 45 -7 30
-5 32 3 28 114 -4 108 -12 226 -20 291 -13 110 -17 142 -20 146 -2 3 -6 26
-10 50 -15 108 -85 360 -107 384 -4 6 -8 18 -8 28 0 10 -7 30 -16 43 -9 14
-12 25 -8 25 5 0 5 4 -1 8 -5 4 -26 39 -45 77 -53 108 -140 230 -207 291 -13
12 -23 23 -23 26 0 3 20 27 45 54 24 27 45 52 45 55 0 3 14 24 30 45 53 66
191 329 204 389 2 6 14 48 29 95 14 47 29 97 32 113 3 15 7 38 10 52 3 13 7
60 9 103 6 112 -20 174 -85 207 -51 27 -77 25 -181 -11 -10 -4 -18 -10 -18
-15 0 -5 -4 -9 -10 -9 -13 0 -48 -30 -124 -102 -33 -32 -60 -58 -60 -58 -1 0
-42 -39 -91 -88 -50 -48 -110 -103 -134 -122 -24 -19 -48 -40 -55 -45 -21 -19
-92 -63 -144 -89 l-52 -26 -26 22 c-15 13 -40 35 -56 51 -17 15 -34 27 -39 27
-4 0 -19 10 -33 23 -31 29 -181 114 -255 145 -92 38 -205 74 -281 88 -14 2
-31 7 -38 9 -40 14 -248 19 -832 18 -597 -1 -715 -4 -790 -19 -14 -3 -34 -6
-45 -8 -11 -2 -27 -6 -35 -10 -8 -3 -26 -7 -40 -10 -64 -10 -290 -100 -330
-131 -8 -6 -35 -23 -60 -37 -25 -14 -80 -53 -122 -87 -43 -34 -84 -61 -92 -61
-18 0 -120 58 -124 71 -2 5 -8 9 -13 9 -9 0 -29 15 -74 55 -13 11 -36 31 -51
44 -38 31 -163 151 -159 151 4 0 -29 31 -145 138 -25 23 -50 42 -57 42 -6 0
-13 4 -15 9 -1 5 -10 11 -18 13 -8 2 -21 9 -28 16 -7 6 -23 12 -35 13 -12 0
-29 2 -38 4 -8 1 -31 -3 -50 -9z"/>
</g>
</svg>
<a title="A loosely organized collection of notes and thoughts
" href="/notes/">Sentences</a></div><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></div><nav class="navigation">
        <ul><li class="navigation__item"><a href="/notes/archive.html">Archive</a></li><li class="navigation__item"><a href="/notes/about.html">About</a></li><li><button class="button button--secondary button--circle search-button js-search-toggle"><i class="fas fa-search"></i></button></li></ul>
      </nav></div>
  </header>
</div><div class="page__content"><div class ="main"><div class="grid grid--reverse">

              <div class="col-aside d-print-none js-col-aside"><aside class="page__aside js-page-aside"><div class="toc-aside js-toc-root"></div>
</aside></div>

              <div class="col-main cell cell--auto"><!-- start custom main top snippet -->

<!-- end custom main top snippet -->
<article itemscope itemtype="http://schema.org/Article"><div class="article__header"><header><h1>Functional Programming Principles in Scala</h1></header><span class="split-space">&nbsp;</span>
          <a class="edit-on-github"
            title="Edit on Github"
            href="https://github.com/ivy-zhou/notes/tree/master/_posts/2020-09-02-progfun.md">
            <i class="far fa-edit"></i></a></div><meta itemprop="headline" content="Functional Programming Principles in Scala"><div class="article__info clearfix"><ul class="left-col menu"><li>
              <a class="button button--secondary button--pill button--sm"
                href="/notes/archive.html?tag=coursera">coursera</a>
            </li><li>
              <a class="button button--secondary button--pill button--sm"
                href="/notes/archive.html?tag=notes">notes</a>
            </li></ul><ul class="right-col menu"><li><i class="far fa-calendar-alt"></i> <span>Sep 02, 2020</span>
            </li></ul></div><meta itemprop="author" content="Ivy Zhou"/><meta itemprop="datePublished" content="2020-09-02T00:00:00+00:00">
    <meta itemprop="keywords" content="coursera,notes"><div class="js-article-content"><div class="layout--article"><!-- start custom article top snippet -->

<!-- end custom article top snippet -->
<div class="article__content" itemprop="articleBody"><p><a href="https://www.coursera.org/learn/progfun1">Functional Programming Principles in Scala | Coursera</a></p>

<h1 id="week-1">Week 1</h1>

<p>Main programming paradigms:</p>

<ul>
  <li>imperative programming â‡’ instruction sequences for a <em>Von Neumann</em> computer (processor, memory, bus)
    <ul>
      <li>Von Neumann bottleneck â‡’ conceptualizing data strictures word-by-word
        <ul>
          <li>So, we need a higher level idea of programming in order to scale up programs</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>functional programming</li>
  <li>logic programming</li>
</ul>

<p>Object-oriented programming is <em>orthogonal</em> to these paradigms because can be used with imperative programming or with functional programming.</p>

<p>We want to implement <em>mathematical theories</em> as functions in code, so we can reason using those theories at a high level. Most theories do not support mutation, so we need to abandon mutation.</p>

<p>Two ways to look at functional programming:</p>

<ul>
  <li>restricted sense: no mutable variables, assignments, or imperative control structures (e.g. for loops)</li>
  <li>wider sense: programs which focus on functions</li>
</ul>

<p>lambda calculus â‡’ substitution model for reducing expressions to simpler forms, works as long as expressions:</p>

<ul>
  <li>donâ€™t have side effects (e.g. <code class="language-plaintext highlighter-rouge">a += 1</code> has a side effect of storing <code class="language-plaintext highlighter-rouge">a</code>)</li>
  <li>terminate (e.g. <code class="language-plaintext highlighter-rouge">def loop = loop</code> does not terminate)</li>
</ul>

<p>Two equivalent evaluation strategies for lambda calculus:</p>

<ul>
  <li>
    <p><strong>call by value</strong> â‡’ evaluate function arguments before function</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">square</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="cm">/**
An example evaluation:
1. square(1 + 2)
2. square(3)
3. 3 * 3
4. 9
**/</span>
</code></pre></div>    </div>

    <ul>
      <li>only evaluates every function argument 1 time</li>
      <li>works better with imperative programming paradigm since we fix the time at which we evaluate function arguments</li>
    </ul>
  </li>
  <li>
    <p><strong>call by name</strong> â‡’ evaluate function first, then arguments if need be</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">square</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="cm">/**
An example evaluation:
1. square(1 + 2)
2. (1 + 2) * (1 + 2)
3. 3 * (1 + 2)
4. 3 * 3
5. 9
**/</span>
</code></pre></div>    </div>

    <ul>
      <li>function argument will not be evaluated if it is unused in the function body
        <ul>
          <li>So, call by value termination ensures call by name termination</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Two equivalent definition strategies:</p>

<ul>
  <li>definition by value â‡’ righthand side is evaluated at the point of definition e.g. <code class="language-plaintext highlighter-rouge">val x = square(3)</code></li>
  <li>definition by name â‡’ righthand side is evaluated on each use e.g. <code class="language-plaintext highlighter-rouge">def three: Int = 3</code></li>
</ul>

<hr />

<h3 id="example-computing-square-roots-with-newtons-method">Example: Computing square roots with Newtonâ€™s method</h3>

<p>Suppose we wish to find the square root of 2. According to Newtonâ€™s method, we guess 1. Next, we find the average of 2 divided by our guess (2/1 = 2) and our guess (1), which is 1.5. So the next guess will be 1.5.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.math.abs</span>

<span class="k">def</span> <span class="nf">sqrt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
	<span class="c1">// Nest helper functions in block to reduce namespace pollution</span>
	<span class="c1">// We don't need to pass constant x to any of these helper functions!</span>
	<span class="k">def</span> <span class="nf">sqrtIter</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="nf">isGoodEnough</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span> <span class="n">guess</span> <span class="k">else</span> <span class="nf">sqrtIter</span><span class="o">(</span><span class="nf">improve</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span>

	<span class="c1">// Divide by x in order to scale for very small/large values for guess</span>
	<span class="k">def</span> <span class="nf">isGoodEnough</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span>
		<span class="nf">abs</span><span class="o">((</span><span class="n">guess</span> <span class="o">*</span> <span class="n">guess</span><span class="o">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span> <span class="o">/</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.001</span>

	<span class="k">def</span> <span class="nf">improve</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span>
		<span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">guess</span> <span class="o">+</span> <span class="n">guess</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>

	<span class="c1">// Always guess 1.0</span>
	<span class="nf">sqrtIter</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>tail recursion</strong> â‡’ a function doing a <em>tail call</em> (calling itself or another function as its last action) can reuse its stack frame and thus <em>iterate</em> in constant space</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Tail recursive</span>
<span class="k">def</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>

<span class="c1">// NOT tail recursive, since we have to multiply by n after calling factorial</span>
<span class="k">def</span> <span class="nf">factorial</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="nf">factorial</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="c1">// Tail recursive</span>
<span class="k">def</span> <span class="nf">factorialTR</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">loop</span><span class="o">(</span><span class="n">acc</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">acc</span> <span class="k">else</span> <span class="nf">loop</span><span class="o">(</span><span class="n">acc</span> <span class="o">*</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
	<span class="nf">loop</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>
<span class="o">}</span>

</code></pre></div></div>

<h1 id="week-2">Week 2</h1>

<p><strong>higher order function</strong> â‡’ function that takes other functions as parameters or returns a function as results</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A higher order function</span>
<span class="c1">// f: Int =&gt; Int means a function f with parameter Int that returns Int</span>
<span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">loop</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">acc</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="n">acc</span>
		<span class="k">else</span> <span class="nf">loop</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">acc</span> <span class="o">+</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
	<span class="o">}</span>
	<span class="nf">loop</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">id</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span>
<span class="k">def</span> <span class="nf">cube</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="k">def</span> <span class="nf">factorial</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="nf">factorial</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="c1">// Or, use anonymous function syntactic sugar; x =&gt; x</span>
<span class="k">def</span> <span class="nf">sumInts</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="c1">// Or, use anonymous function syntactic sugar; x =&gt; x * x * x</span>
<span class="k">def</span> <span class="nf">sumCubes</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">cube</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">sumFactorials</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">factorial</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div></div>

<p>Notice that in <code class="language-plaintext highlighter-rouge">sumInts</code>, <code class="language-plaintext highlighter-rouge">sumCubes</code>, and <code class="language-plaintext highlighter-rouge">sumFactorials</code>, we accept parameters <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> and we simply pass them on. We can avoid this repetition like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Syntactic sugar for function returning functions</span>
<span class="c1">// Its type is (Int =&gt; Int) =&gt; ((Int, Int) =&gt; Int)</span>
<span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">+</span> <span class="nf">sum</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>

<span class="c1">// Then, we can define w/o (a, b) and use these like sumCubes(1, 10) as before</span>
<span class="k">def</span> <span class="nf">sumInts</span> <span class="k">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">sumCubes</span> <span class="k">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">sumFactorials</span> <span class="k">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">factorial</span><span class="o">)</span>

<span class="c1">// Or, use the general function directly</span>
<span class="nf">sum</span><span class="o">(</span><span class="n">cube</span><span class="o">)(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</code></pre></div></div>

<p>In general, a definition of a function with n parameter lists applied in sequence, where n &gt; 1</p>

\[\text{def f}(args_1)\cdots(args_n) = E\]

<p>can be rewritten as:</p>

\[\text{def f}(args_1)\cdots(args_{n - 1}) = \{ \text{def g}(args_n) = E; g\}\]

<p>or for short, without g:</p>

\[\text{def f}(args_1)\cdots(args_{n - 1}) = (args_n \rightarrow E)\]

<p>Rewriting n times, we have:</p>

\[\text{def f} = (args_1 \rightarrow (args_2 \rightarrow \cdots (args_n \rightarrow E)\cdots))\]

<p>Defining functions in this style is called <strong>currying</strong>.</p>

<p>Now letâ€™s write a function <code class="language-plaintext highlighter-rouge">product</code> that computes the products from integers in the range <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">b</code> using currying, like we did before with <code class="language-plaintext highlighter-rouge">sum</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">product</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">*</span> <span class="nf">product</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">factorial</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nf">product</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">)(</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span>
</code></pre></div></div>

<p>And, a more general function that generalizes both <code class="language-plaintext highlighter-rouge">sum</code> and <code class="language-plaintext highlighter-rouge">product</code> :</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// f =&gt; map function to apply to each element</span>
<span class="c1">// combine =&gt; reduce elements after mapping</span>
<span class="c1">// zero =&gt; value to return if the range is empty</span>
<span class="k">def</span> <span class="nf">mapReduce</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">,</span> <span class="n">combine</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span><span class="o">,</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="n">zero</span> <span class="k">else</span> <span class="nf">combine</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="nf">mapReduce</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">combine</span><span class="o">,</span> <span class="n">zero</span><span class="o">)(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>

<span class="k">def</span> <span class="nf">product</span> <span class="k">=</span> <span class="nf">mapReduce</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">,</span> <span class="mi">1</span><span class="o">)(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">sum</span> <span class="k">=</span> <span class="nf">mapReduce</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">,</span> <span class="mi">0</span><span class="o">)(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div></div>

<hr />

<h2 id="example-finding-a-fixed-point-of-a-function">Example: Finding a fixed point of a function</h2>

<p>A number x is a <em>fixed point</em> of a function f if f(x) = x. To find the fixed point x of some function f, we can start with an initial estimate for x, and compute f(x). If f(x) is sufficiently close to x, weâ€™ve found x. If not, we try f(f(x)) as our new estimate. We can repeat this process until we get a sufficiently close x. (This only works for some functions.)</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">tolerance</span> <span class="k">=</span> <span class="mf">0.0001</span>

<span class="k">def</span> <span class="nf">isCloseEnough</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span>
	<span class="nf">abs</span><span class="o">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">)</span> <span class="o">/</span> <span class="n">x</span><span class="o">)</span> <span class="o">/</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">tolerance</span>

<span class="k">def</span> <span class="nf">fixedPoint</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="nc">Double</span><span class="o">)(</span><span class="n">firstGuess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">iterate</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
		<span class="k">val</span> <span class="nv">next</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="n">guess</span><span class="o">)</span>
		<span class="nf">if</span> <span class="o">(</span><span class="nf">isCloseEnough</span><span class="o">(</span><span class="n">guess</span><span class="o">,</span> <span class="n">next</span><span class="o">))</span> <span class="n">next</span>
		<span class="k">else</span> <span class="nf">iterate</span><span class="o">(</span><span class="n">next</span><span class="o">)</span>
	<span class="o">}</span>
	<span class="nf">iterate</span><span class="o">(</span><span class="n">firstGuess</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Find the fixed point of f(x) = 1 + x / 2</span>
<span class="nf">fixedPoint</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="o">)(</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>Recall that the square root of x is defined as y such that y * y = x. Dividing by y on both sides, we have that the square root of x is y such that y = x / y. So, the square root of x is the fixed point y of the function y â‡’ x / y.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sqrt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="nf">fixedPoint</span><span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">)(</span><span class="mi">1</span><span class="o">)</span>

<span class="c1">// Unfortunately, this doesn't converge (guesses oscillate between 1 and 2)</span>
<span class="nf">sqrt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>

<span class="c1">// To fix this, we can average our last guess (y) and the current guess (x/y)</span>
<span class="k">def</span> <span class="nf">sqrt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="nf">fixedPoint</span><span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)(</span><span class="mi">1</span><span class="o">)</span>

<span class="c1">// Stabilizing by averaging can be written in general as:</span>
<span class="k">def</span> <span class="nf">averageDamp</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="nc">Double</span><span class="o">)(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span>

<span class="c1">// Using this in sqrt, we have</span>
<span class="k">def</span> <span class="nf">sqrt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="nf">fixedPoint</span><span class="o">(</span><span class="nf">averageDamp</span><span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">))(</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<hr />

<p>Letâ€™s write a class for rational numbers in Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Implicit primary constructor</span>
<span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

	<span class="nf">require</span><span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"denominator must be nonzero"</span><span class="o">)</span>

	<span class="c1">// Alternate constructor</span>
	<span class="k">def</span> <span class="nf">this</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nf">this</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

	<span class="k">private</span> <span class="k">def</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>

	<span class="c1">// We could also simplify only at print time, but we could run into overflow</span>
	<span class="k">def</span> <span class="nf">numer</span> <span class="k">=</span> <span class="n">x</span> <span class="o">/</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">denom</span> <span class="k">=</span> <span class="n">y</span> <span class="o">/</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>

	<span class="k">def</span> <span class="nf">&lt;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">*</span> <span class="nv">that</span><span class="o">.</span><span class="py">denom</span> <span class="o">&lt;</span> <span class="nv">that</span><span class="o">.</span><span class="py">numer</span> <span class="o">*</span> <span class="n">denom</span>

	<span class="k">def</span> <span class="nf">max</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">)</span> <span class="n">that</span> <span class="k">else</span> <span class="k">this</span>

	<span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
		<span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
			<span class="n">numer</span> <span class="o">*</span> <span class="nv">that</span><span class="o">.</span><span class="py">denom</span> <span class="o">+</span> <span class="nv">that</span><span class="o">.</span><span class="py">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
			<span class="n">denom</span> <span class="o">*</span> <span class="nv">that</span><span class="o">.</span><span class="py">denom</span>
		<span class="o">)</span>

	<span class="k">def</span> <span class="nf">unary_-</span> <span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(-</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span>

	<span class="k">def</span> <span class="nf">-</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span> <span class="o">+</span> <span class="o">-</span><span class="n">that</span>

	<span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">denom</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="nv">x</span><span class="o">.</span><span class="py">numer</span> <span class="c1">// 1</span>
<span class="nv">x</span><span class="o">.</span><span class="py">denom</span> <span class="c1">// 2</span>

<span class="k">val</span> <span class="nv">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="c1">// 7/6</span>

<span class="k">val</span> <span class="nv">strange</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// IllegalArgumentException from require</span>
</code></pre></div></div>

<p>require â‡’ used to enforce a precondition on the caller of a function</p>

<p>assert â‡’ used to check the code of the function itself</p>

<p>We can formally define the evaluation of a class method call using substitution much the same way as we defined the evaluation of a function call.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">).</span><span class="py">numer</span>
<span class="c1">// [1/x, 2/y][][new Rational(1, 2) / this] x</span>
<span class="c1">//  --------- substitute class parameters x and y</span>
<span class="c1">//           -- substitute function parameters for numer</span>
<span class="c1">//             --------------------------- sustitute this for Rational object</span>
<span class="c1">//                                         - function body</span>

<span class="c1">// Evaluation:</span>
<span class="c1">// = 1</span>

<span class="k">new</span> <span class="nf">rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">).</span><span class="py">less</span><span class="o">(</span><span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="c1">// [1/x, 2/y][new Rational(2, 3) / that][new Rational(1, 2) / this]</span>
<span class="c1">// this.numer * that.denom &lt; that.numer * this.denom</span>

<span class="c1">// Evaluation:</span>
<span class="c1">// = new Rational(1, 2).numer * new Rational(2, 3).denom &lt;</span>
<span class="c1">//   new Rational(2, 3).numer * new Rational(1, 2).denom</span>
<span class="c1">// = 1 * 3 &lt; 2 * 2</span>
<span class="c1">// = true</span>
</code></pre></div></div>

<p>Any method with a parameter can be used like an infix operator:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span> <span class="n">max</span> <span class="n">s</span> <span class="o">===</span> <span class="nv">r</span><span class="o">.</span><span class="py">max</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</code></pre></div></div>

<p>Identifiers in Scala can be:</p>

<ul>
  <li>alphanumeric (includes <code class="language-plaintext highlighter-rouge">_</code>)</li>
  <li>symbolic</li>
  <li>a mix of alphanumeric and symbolic</li>
</ul>

<p>Precedence of an operator is determined by its first character. In order of increasing priority:</p>

<ol>
  <li>All letters</li>
  <li>
    <table>
      <tbody>
        <tr>
        </tr>
      </tbody>
    </table>
  </li>
  <li></li>
  <li>&amp;</li>
  <li>&lt; &gt;</li>
  <li>= !</li>
  <li>
    <ul>
      <li>-</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>/ %</li>
    </ul>
  </li>
  <li>All other special characters</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Evaluation of precendence example:</span>
<span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">^?</span> <span class="n">c</span> <span class="o">?^</span> <span class="n">d</span> <span class="n">less</span> <span class="n">a</span> <span class="o">==&gt;</span> <span class="n">b</span> <span class="o">|</span> <span class="n">c</span><span class="o">)</span> <span class="o">===</span> <span class="o">(</span>

<span class="o">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">^?</span> <span class="o">(</span><span class="n">c</span> <span class="o">?^</span> <span class="n">d</span><span class="o">))</span> <span class="nf">less</span> <span class="o">((</span><span class="n">a</span> <span class="o">==&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">|</span> <span class="n">c</span><span class="o">)</span>

<span class="o">)</span>
</code></pre></div></div>

<h1 id="week-3">Week 3</h1>

<p>Letâ€™s write a class for sets of integers to demonstrate class inheritance.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">IntSet</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">incl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span>
	<span class="k">def</span> <span class="nf">union</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span>
<span class="o">}</span>

<span class="c1">// Let's implement IntSet as a binary tree</span>

<span class="c1">// object keyword =&gt; singleton value, since all instances of Empty are the same</span>
<span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">IntSet</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
	<span class="k">def</span> <span class="nf">incl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Intset</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="c1">// not `new Empty`</span>
	<span class="k">def</span> <span class="nf">union</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span> <span class="o">=</span> <span class="n">other</span>
	<span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span> <span class="s">"."</span>
<span class="o">}</span>

<span class="c1">// NonEmpty has the base classes IntSet and Object</span>
<span class="c1">// Object is a default base class for all user-defined classes, like in Java</span>
<span class="k">class</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">left</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IntSet</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">elem</span><span class="o">)</span> <span class="n">left</span> <span class="n">contains</span> <span class="n">x</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">elem</span><span class="o">)</span> <span class="n">right</span> <span class="n">contains</span> <span class="n">x</span>
		<span class="k">else</span> <span class="kc">true</span>

	<span class="k">def</span> <span class="nf">incl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span> <span class="o">=</span>
		<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">elem</span><span class="o">)</span> <span class="k">new</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">left</span> <span class="n">incl</span> <span class="n">x</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">elem</span><span class="o">)</span> <span class="k">new</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="n">incl</span> <span class="n">x</span><span class="o">)</span>
		<span class="k">else</span> <span class="k">this</span>

	<span class="c1">// this terimnates because each call to union is on a set that is smaller</span>
	<span class="k">def</span> <span class="nf">union</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span> <span class="o">=</span> <span class="o">((</span><span class="n">left</span> <span class="n">union</span> <span class="n">right</span><span class="o">)</span> <span class="n">union</span> <span class="n">other</span><span class="o">)</span> <span class="n">incl</span> <span class="n">elem</span>

	<span class="c1">// You cannot override a base class method without the override keyword</span>
	<span class="c1">// Using override without a base class method being overriden is legal, but</span>
	<span class="c1">// gives a warning</span>
	<span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span> <span class="s">"{"</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">elem</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="s">"}"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>dynamic method dispatch</strong> â‡’ code invoked by a method call depends on the runtime type of the object that contains the method</p>

<p>Notice that dynamic method dispatch is analogous to calls to higher order functions.</p>

<p>Classes and objects are organized in packages, like in Java.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">profun.examples</span>

<span class="k">import</span> <span class="nn">week3.IntSet</span> <span class="c1">// import IntSet from week 3</span>
<span class="k">import</span> <span class="nn">week2.</span><span class="o">{</span><span class="nc">Rational</span><span class="o">,</span> <span class="nc">FunSet</span><span class="o">}</span> <span class="c1">// import 2 things from week 2</span>
<span class="k">import</span> <span class="nn">week1._</span> <span class="c1">// import everything from week 1</span>

<span class="c1">// places Hello in the pacakge "profun.examples"</span>
<span class="k">object</span> <span class="nc">Hello</span> <span class="o">{</span>
	<span class="c1">// run in cmdline with `scala profun.examples.Hello`</span>
	<span class="k">def</span> <span class="nf">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="nf">println</span><span class="o">(</span><span class="s">"hello world!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Entities always imported in any Scala program:</p>

<ul>
  <li>all members of package <code class="language-plaintext highlighter-rouge">scala</code></li>
  <li>all members of package <code class="language-plaintext highlighter-rouge">java.lang</code></li>
  <li>all members of the singleton object <code class="language-plaintext highlighter-rouge">scala.Predef</code></li>
</ul>

<p>Scala is a <em>single inheritance</em> language, meaning that a class can only have one superclass. Use <strong>traits</strong> to allow a class to include code from several supertypes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Traits cannot have value parameters, unlike classes</span>
<span class="k">trait</span> <span class="nc">Planar</span> <span class="o">{</span>
	<span class="c1">// Can contain fields and concrete methods</span>
	<span class="k">def</span> <span class="nf">height</span><span class="k">:</span> <span class="kt">Int</span>
	<span class="k">def</span> <span class="nf">width</span><span class="k">:</span> <span class="kt">Int</span>
	<span class="k">def</span> <span class="nf">surface</span> <span class="k">=</span> <span class="n">height</span> <span class="o">*</span> <span class="n">width</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Square</span> <span class="k">extends</span> <span class="nc">Shape</span> <span class="k">with</span> <span class="nc">Planar</span> <span class="k">with</span> <span class="nc">Movable</span> <span class="o">...</span>
</code></pre></div></div>

<p>We call two entities that can convert to each other a <strong>view</strong> of each other. A view relationship is not the same as a subtype/supertype relationship because:</p>

<ol>
  <li>Converting to an alternate view requires a change in the representation of the data</li>
  <li>Converting to an alternate view may be lossy</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">Nothing</code> type in Scala is used for:</p>

<ul>
  <li>element type of empty collections e.g. <code class="language-plaintext highlighter-rouge">Set[Nothing]</code></li>
  <li>signaling abnormal termination e.g. <code class="language-plaintext highlighter-rouge">throw Exception</code> has type <code class="language-plaintext highlighter-rouge">Nothing</code></li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">if</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">false</span> <span class="c1">// expression has type AnyVal</span>
</code></pre></div></div>

<p>Letâ€™s look at the <em>cons list</em> data structure. The cons list is an immutable list that consists of:</p>

<ul>
  <li>Nil â‡’ the empty list, and</li>
  <li>Cons â‡’ cell containing the first element of the list and a pointer reference to the rest of the list</li>
</ul>

<p>For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="cm">/**
is represented as:
[]
| \
1 []
  | \
  2  []
     | \
     3  Nil
**/</span>
<span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="cm">/**
is represented as:
  []
 /  \_________
[]            []
| \           | \
1 []          []  Nil
  | \         | \
  0  Nil      3  Nil
**/</span>
</code></pre></div></div>

<p>Now letâ€™s implement it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">T</span>
	<span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// use of "val" in the constructor defines fields `head` and `tail`</span>
<span class="c1">// this also implements `def head` and `def tail` in the trait List[T]</span>
<span class="k">class</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">val</span> <span class="nv">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="k">val</span> <span class="nv">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
	<span class="c1">// Nothing is a subtype of T, so this definition works</span>
	<span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"Nil.head"</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"Nil.tail"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">singleton</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elem</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Nil</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>

<span class="c1">// use as:</span>
<span class="n">singleton</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">)</span>
<span class="nf">singleton</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="c1">// Scala compiler infers T as Boolean</span>

<span class="c1">// 0 index =&gt; 1st element</span>
<span class="k">def</span> <span class="nf">nth</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
	<span class="nf">if</span><span class="o">(</span><span class="nv">xs</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IndexOutOfBoundsException</span>
	<span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nv">xs</span><span class="o">.</span><span class="py">head</span>
	<span class="k">else</span> <span class="nf">nth</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="nv">xs</span><span class="o">.</span><span class="py">tail</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">list</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Nil</span><span class="o">)))</span>
<span class="nf">nth</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">list</span><span class="o">)</span> <span class="c1">// 3</span>
<span class="nf">nth</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="n">list</span><span class="o">)</span> <span class="c1">// IndexOutOfBoundsException</span>
</code></pre></div></div>

<p><strong>type erasure</strong> â‡’ type parameters are removed so that they cannot affect evaluation of the program</p>

<p><strong>Polymorphism</strong> comes in two principal forms:</p>

<ol>
  <li>subtyping â‡’ instances of a subclass can be referenced as a base class e.g. <code class="language-plaintext highlighter-rouge">class Square extends Shape</code></li>
  <li>generics â‡’ instances of a function/class can be created by type parameterization e.g. <code class="language-plaintext highlighter-rouge">List[T]</code></li>
</ol>

<h1 id="week-4">Week 4</h1>

<p><strong>pure object-oriented language</strong> â‡’ every value is an object, every operation is a method on some object</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">idealized.scala</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Boolean</span> <span class="o">{</span>
	<span class="c1">// if (cond) t else e === cond.ifThenElse(t, e)</span>
	<span class="k">def</span> <span class="nf">ifThenElse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">,</span> <span class="n">e</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>

	<span class="c1">// cond &amp;&amp; x === if (cond) then x else false</span>
	<span class="k">def</span> <span class="nf">&amp;&amp;</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nf">ifThenElse</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">||</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nf">ifThenElse</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">unary_!:</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="nf">ifThenElse</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>

	<span class="k">def</span> <span class="nf">==</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nf">ifThenElse</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nv">x</span><span class="o">.</span><span class="py">unary_!</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">!=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nf">ifThenElse</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">unary_!</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
	<span class="c1">// Assume false &lt; true</span>
	<span class="k">def</span> <span class="nf">&lt;</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nf">ifThenElse</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">true</span> <span class="k">extends</span> <span class="nc">Boolean</span> <span class="o">{</span>
	<span class="c1">// if (true) t else e === t</span>
	<span class="k">def</span> <span class="nf">ifThenElse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">,</span> <span class="n">e</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">t</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">false</span> <span class="k">extends</span> <span class="nc">Boolean</span> <span class="o">{</span>
	<span class="c1">// if (false) t else e === e</span>
	<span class="k">def</span> <span class="nf">ifThenElse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">,</span> <span class="n">e</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">e</span>
<span class="o">}</span>
</code></pre></div></div>

<p>A partial specification of class <code class="language-plaintext highlighter-rouge">scala.Int</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Int</span> <span class="o">{</span>
	<span class="c1">// method overloading is allowed, as in Java</span>
	<span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span>
	<span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span><span class="k">:</span> <span class="kt">Float</span>
	<span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span>
	<span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// same for -, *, /, %</span>

	<span class="k">def</span> <span class="nf">&lt;&lt;</span> <span class="o">(</span><span class="n">cnt</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// same for &gt;&gt;</span>

	<span class="k">def</span> <span class="nf">&amp;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span>
	<span class="k">def</span> <span class="nf">&amp;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// same for |, ^</span>

	<span class="k">def</span> <span class="nf">==</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">==</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">==</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="c1">// same for !=, &lt;, &gt;, &lt;=, &gt;=</span>
<span class="o">}</span>

<span class="c1">// Natural number class (simplified Int class)</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Nat</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isZero</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">predecessor</span><span class="k">:</span> <span class="kt">Nat</span> <span class="c1">// returns the previous natural number before this</span>
	<span class="k">def</span> <span class="nf">successor</span><span class="k">:</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Succ</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="c1">// returns the next natural number after this</span>
	<span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Nat</span><span class="o">)</span><span class="k">:</span> <span class="kt">Nat</span>
	<span class="k">def</span> <span class="nf">-</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Nat</span><span class="o">)</span><span class="k">:</span> <span class="kt">Nat</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Zero</span> <span class="k">extends</span> <span class="nc">Nat</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isZero</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
	<span class="k">def</span> <span class="nf">predecessor</span><span class="k">:</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"0.predecessor"</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Nat</span><span class="o">)</span><span class="k">:</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="n">that</span>
	<span class="k">def</span> <span class="nf">-</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Nat</span><span class="o">)</span><span class="k">:</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">that</span><span class="o">.</span><span class="py">isZero</span><span class="o">)</span> <span class="k">this</span> <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"negative number"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Succ</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Nat</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Nat</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isZero</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
	<span class="k">def</span> <span class="nf">predecessor</span><span class="k">:</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="n">n</span>
	<span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Nat</span><span class="o">)</span><span class="k">:</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Succ</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">that</span><span class="o">)</span>
	<span class="c1">// 5 - 2 =&gt; 4 - 1 =&gt; 3 - 0 =&gt; 3</span>
	<span class="k">def</span> <span class="nf">-</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Nat</span><span class="o">)</span><span class="k">:</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">that</span><span class="o">.</span><span class="py">isZero</span><span class="o">)</span> <span class="k">this</span> <span class="k">else</span> <span class="n">n</span> <span class="o">-</span> <span class="nv">that</span><span class="o">.</span><span class="py">predecessor</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can also treat functions as objects.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">scala</span>

<span class="c1">// Function2, Function3 ... Function22 also exist to take more parameters</span>
<span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
<span class="o">}</span>

<span class="c1">// We can write `def f(x: Int) =&gt; x * x` by eta-expansion as:</span>
<span class="k">val</span> <span class="nv">f1</span> <span class="k">=</span> <span class="o">{</span>
	<span class="k">class</span> <span class="nc">AnonFun</span> <span class="k">extends</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
	<span class="o">}</span>
	<span class="k">new</span> <span class="nc">AnonFun</span>
<span class="o">}</span>
<span class="c1">// or, using anonymous class syntax (also in Java):</span>
<span class="k">val</span> <span class="nv">f2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
	<span class="c1">// Notice, the apply method itself is not a function object, because that</span>
	<span class="c1">// would be an infinite recursive definition</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span>
<span class="c1">// Then, f(7) would be</span>
<span class="nv">f2</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
</code></pre></div></div>

<p>Letâ€™s do an exercise with Lists to allow them to accept multiple parameters in the same way <code class="language-plaintext highlighter-rouge">Function</code> does.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">T</span>
	<span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">val</span> <span class="nv">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="k">val</span> <span class="nv">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
	<span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"Nil.head"</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"Nil.tail"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">List</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x1</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">x2</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x2</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Nil</span><span class="o">))</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Nil</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Nil</span>
<span class="o">}</span>

<span class="c1">// This lets us instantiate lists up to length 2</span>
<span class="nc">List</span><span class="o">()</span> <span class="c1">// the empty list</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// list with single element 1</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">// list with elements 2, 3</span>
</code></pre></div></div>

<h3 id="type-bounds">Type Bounds</h3>

<p>Suppose we had a method <code class="language-plaintext highlighter-rouge">assertAllPos</code> that for a given <code class="language-plaintext highlighter-rouge">IntSet</code>, returns the <code class="language-plaintext highlighter-rouge">IntSet</code> if all of its elements are positive and throws an exception otherwise. We could declare <code class="language-plaintext highlighter-rouge">assertAllPos</code> as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">assertAllPos</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">IntSet</span>
</code></pre></div></div>

<p>But return type <code class="language-plaintext highlighter-rouge">IntSet</code> doesnâ€™t capture the fact that <code class="language-plaintext highlighter-rouge">assertAllPos</code> can return <code class="language-plaintext highlighter-rouge">Empty</code>, <code class="language-plaintext highlighter-rouge">NonEmpty</code>, or throw an error. Instead, we could use bounds to declare it as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// S &lt;: T means that S is a subtype of T, T is an upper bound of type S</span>
<span class="c1">// S &gt;: T would mean that S is a supertype of T</span>
<span class="c1">// So, assertAllPos takes a subtype of IntSet and returns it</span>
<span class="k">def</span> <span class="nf">assertAllPos</span><span class="o">(</span><span class="n">S</span> <span class="k">&lt;:</span> <span class="nc">IntSet</span><span class="o">)(</span><span class="n">r</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>

<span class="c1">// If assertAllPos threw an exception if the set was empty, we could write:</span>
<span class="k">def</span> <span class="nf">assertNotEmptyAndAllPos</span><span class="o">(</span><span class="n">S</span> <span class="k">&gt;:</span> <span class="nc">NonEmpty</span> <span class="k">&lt;:</span> <span class="nc">IntSet</span><span class="o">)(</span><span class="n">r</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>
</code></pre></div></div>

<h3 id="covariance">Covariance</h3>

<p>Suppose <code class="language-plaintext highlighter-rouge">NonEmpty &lt;: IntSet</code>. Then <code class="language-plaintext highlighter-rouge">List[NonEmpty] &lt;: List[IntSet]</code>, since a list of Int sets is a special case of a list of arbitrary non-empty sets. So, we call <code class="language-plaintext highlighter-rouge">List</code> a <em>covariant</em> type, because it has a type parameter that allows for subtyping relationships.</p>

<p>For example, arrays in Java are covariant, e.g. <code class="language-plaintext highlighter-rouge">NonEmpty &lt;: IntSet</code>. But this causes problems:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">NonEmpty</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NonEmpty</span><span class="o">{</span> <span class="k">new</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="o">}</span>
<span class="nc">IntSet</span><span class="o">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Empty</span> <span class="c1">// runtime ArrayStoreException</span>
<span class="nc">NonEmpty</span> <span class="n">s</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="c1">// Oh no! We're assigning Empty to the NonEmpty var s!</span>
</code></pre></div></div>

<p>We want line 4 to be impossible, so at runtime when the array is created, Java stores a type tag for <code class="language-plaintext highlighter-rouge">a</code> that says that <code class="language-plaintext highlighter-rouge">a</code> is meant to be an array of <code class="language-plaintext highlighter-rouge">NonEmpty</code>. Then it checks this type tag before assignment on line 3, and throws a <code class="language-plaintext highlighter-rouge">ArrayStoreException</code> so that line 4 is impossible. But this runtime check is inefficient!</p>

<p>We have this design in Java because it allowed for sorting methods that could sort arrays of any type:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Sorts arrays of all types, because Object is a base type of all types</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span>

<span class="c1">// But generics (introduced later) are a better compile-time check</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="n">sortGeneric</span><span class="o">[</span><span class="no">T</span><span class="o">](</span><span class="no">T</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span>
</code></pre></div></div>

<p><strong>Liskov Substitution Principle</strong> â‡’ If <code class="language-plaintext highlighter-rouge">A &lt;: B</code>, then everything one can do with a value of type <code class="language-plaintext highlighter-rouge">B</code>, one should also be able to do with type <code class="language-plaintext highlighter-rouge">A</code></p>

<p>Letâ€™s take a look at the same example from Java, written in Scala. This time, weâ€™d have a type error on line 2, since arrays are not covariant in Scala. Instead, <code class="language-plaintext highlighter-rouge">Array</code> in Scala accepts a generic.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">NonEmpty</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="k">new</span> <span class="nc">NonEmpty</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">b</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">IntSet</span><span class="o">]</span> <span class="k">=</span> <span class="n">a</span>
<span class="nf">b</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Empty</span> <span class="c1">// notice b(0), because arrays are a form of method call in Scala</span>
<span class="k">val</span> <span class="nv">s</span><span class="k">:</span> <span class="kt">NonEmpty</span> <span class="o">=</span> <span class="nf">a</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</code></pre></div></div>

<p>As a rule of thumb, if a type is mutable (e.g. <code class="language-plaintext highlighter-rouge">Array</code>) it should not be covariant. If a type is immutable (e.g. <code class="language-plaintext highlighter-rouge">List</code>) it <em>can</em> be covariant.</p>

<p>In general, for a parameterized type <code class="language-plaintext highlighter-rouge">C[T]</code> where <code class="language-plaintext highlighter-rouge">A &lt;: B</code> , there are three possible relationships between <code class="language-plaintext highlighter-rouge">C[A]</code> and <code class="language-plaintext highlighter-rouge">C[B]</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">C[A] &lt;: C[B]</code> â‡’ C is <em>covariant</em>, declared as <code class="language-plaintext highlighter-rouge">class C[+A] { ... }</code></li>
  <li><code class="language-plaintext highlighter-rouge">C[A] &gt;: C[B]</code> â‡’ C is <em>contravariant</em>, declared as <code class="language-plaintext highlighter-rouge">class C[-A] { ... }</code></li>
  <li><code class="language-plaintext highlighter-rouge">C[A]</code> is not a subtype of <code class="language-plaintext highlighter-rouge">C[B]</code>, and the vice versa also holds â‡’ C is <em>nonvariant</em>, declared as <code class="language-plaintext highlighter-rouge">class C[A] { ... }</code></li>
</ul>

<p>For example, if you had two function types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="nc">IntSet</span> <span class="k">=&gt;</span> <span class="nc">NonEmpty</span>
<span class="k">type</span> <span class="kt">B</span> <span class="o">=</span> <span class="nc">NonEmpty</span> <span class="k">=&gt;</span> <span class="nc">IntSet</span>
</code></pre></div></div>

<p>Then according to the Liskov Substitution principle, <code class="language-plaintext highlighter-rouge">A &lt;: B</code>, since <code class="language-plaintext highlighter-rouge">B</code>â€™s <code class="language-plaintext highlighter-rouge">NonEmpty</code> parameter would be accepted as <code class="language-plaintext highlighter-rouge">A</code>â€™s <code class="language-plaintext highlighter-rouge">IntSet</code> parameter and <code class="language-plaintext highlighter-rouge">A</code>â€™s <code class="language-plaintext highlighter-rouge">NonEmpty</code> return value would be accepted as <code class="language-plaintext highlighter-rouge">B</code>â€™s <code class="language-plaintext highlighter-rouge">IntSet</code> return value. So, you could substitute any <code class="language-plaintext highlighter-rouge">A</code> for any <code class="language-plaintext highlighter-rouge">B</code>.</p>

<p>In general, if <code class="language-plaintext highlighter-rouge">A2 &lt;: A1</code> and <code class="language-plaintext highlighter-rouge">B1 &lt;: B2</code>, then <code class="language-plaintext highlighter-rouge">A1 =&gt; B1 &lt;: A2 =&gt; B2</code>. So, functions are <em>contravariant</em> in their argument type (<code class="language-plaintext highlighter-rouge">A1 &gt;: A2</code>) and <em>covariant</em> in their result type (<code class="language-plaintext highlighter-rouge">B1 &lt;: B2</code>).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">scala</span>
<span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-T</span>, <span class="kt">+U</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The Scala compiler makes it impossible to implement a covariant array like in Java through compile time checks:</p>

<ul>
  <li>covariant type parameters can only appear in method results</li>
  <li>contravariant type parameters can only appear in method parameters</li>
  <li>invariant type parameters can appear anywhere</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A Java covariant array would look something like this</span>
<span class="k">class</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
	<span class="c1">// Impossible, since T is method parameter which is covariant</span>
	<span class="k">def</span> <span class="nf">update</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Letâ€™s improve the previous <code class="language-plaintext highlighter-rouge">List</code> example using covariance. Recall that we wanted <code class="language-plaintext highlighter-rouge">Nil</code> to be an object, since there is only one empty list. While weâ€™re also at it, letâ€™s also implement a prepend method for lists.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Covariance is necessary so that List[Nothing] &lt;: List[T]</span>
<span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">T</span>
	<span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
	<span class="c1">// covariant types can be lower bounds, contravariant types can be upper bounds</span>
	<span class="k">def</span> <span class="nf">prepend</span> <span class="o">[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">]</span> <span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">val</span> <span class="nv">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="k">val</span> <span class="nv">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="c1">// use Nothing instead of T because objects cannot have type parameters</span>
<span class="k">object</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
	<span class="c1">// Nothing == Nothing</span>
	<span class="k">def</span> <span class="nf">head</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"Nil.head"</span><span class="o">)</span>
	<span class="c1">// Nothing &lt;: List[Nothing]</span>
	<span class="k">def</span> <span class="nf">tail</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"Nil.tail"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">List</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x1</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">x2</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x2</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Nil</span><span class="o">))</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Nil</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Nil</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span>

<span class="c1">// f returns type List[IntSet] since in prepend,</span>
<span class="c1">// T would be NonEmpty and U would be empty</span>
<span class="c1">// But U &gt;: T is false! So the type inferencer picks the lowest possible U, IntSet</span>
<span class="k">def</span> <span class="nf">f</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">NonEmpty</span><span class="o">],</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Empty</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">prepend</span> <span class="n">x</span>
</code></pre></div></div>

<h2 id="decomposition">Decomposition</h2>

<p>Suppose you want to write an interpreter for arithmetic expressions consisting of just numbers and additions. We can represent an expression as a tree of <code class="language-plaintext highlighter-rouge">Number</code> and <code class="language-plaintext highlighter-rouge">Sum</code> objects.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Expr</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isNumber</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">isSum</span><span class="k">:</span> <span class="kt">Boolean</span>
	<span class="k">def</span> <span class="nf">numValue</span><span class="k">:</span> <span class="kt">Int</span>
	<span class="k">def</span> <span class="nf">leftOp</span><span class="k">:</span> <span class="kt">Expr</span>
	<span class="k">def</span> <span class="nf">rightOp</span><span class="k">:</span> <span class="kt">Expr</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isNumber</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
	<span class="k">def</span> <span class="nf">isSum</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
	<span class="k">def</span> <span class="nf">numValue</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
	<span class="k">def</span> <span class="nf">leftOp</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Number.leftOp"</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">rightOp</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Number.rightOp"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">isNumber</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
	<span class="k">def</span> <span class="nf">isSum</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
	<span class="k">def</span> <span class="nf">numValue</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Sum.numValue"</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">leftOp</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">e1</span>
	<span class="k">def</span> <span class="nf">rightOp</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">e2</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
	<span class="nf">if</span> <span class="o">(</span><span class="nv">e</span><span class="o">.</span><span class="py">isNumber</span><span class="o">)</span> <span class="nv">e</span><span class="o">.</span><span class="py">numValue</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">e</span><span class="o">.</span><span class="py">isSum</span><span class="o">)</span> <span class="nf">eval</span><span class="o">(</span><span class="nv">e</span><span class="o">.</span><span class="py">leftOp</span><span class="o">)</span> <span class="o">+</span> <span class="nf">eval</span><span class="o">(</span><span class="nv">e</span><span class="o">.</span><span class="py">rightOp</span><span class="o">)</span>
	<span class="c1">// We could have an expression which is not a number or a sum!</span>
	<span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Unkown expression "</span> <span class="o">+</span> <span class="n">e</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Letâ€™s say that we now want to add a class for variables and a class for products. Because of how weâ€™ve implemented <code class="language-plaintext highlighter-rouge">Expr</code>, weâ€™d need new classification methods <code class="language-plaintext highlighter-rouge">isProd</code> and <code class="language-plaintext highlighter-rouge">isVar</code> as well a new accessor <code class="language-plaintext highlighter-rouge">name</code> method. So, to implement <code class="language-plaintext highlighter-rouge">Prod</code> and <code class="language-plaintext highlighter-rouge">Var</code>, we would need 8 _ 5 - 5 _ 3 = 25 new methods.</p>

<p>So, this implementation of <code class="language-plaintext highlighter-rouge">Expr</code> doesnâ€™t scale to new classes. Technically, instead of <code class="language-plaintext highlighter-rouge">isProd</code> and friends we could use the <code class="language-plaintext highlighter-rouge">isInstanceOf</code> check built into Scala, but this is discouraged. To see why, letâ€™s look at this very messy version of <code class="language-plaintext highlighter-rouge">eval</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using type tests and type casts, the Expr class could be empty</span>
<span class="k">def</span> <span class="nf">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="nv">e</span><span class="o">.</span><span class="py">istanceOf</span><span class="o">[</span><span class="kt">Number</span><span class="o">])</span>
		<span class="nv">e</span><span class="o">.</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">Number</span><span class="o">].</span><span class="py">numValue</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">e</span><span class="o">.</span><span class="py">instanceOf</span><span class="o">[</span><span class="kt">Sum</span><span class="o">])</span>
		<span class="nf">eval</span><span class="o">(</span><span class="nv">e</span><span class="o">.</span><span class="py">InstanceOf</span><span class="o">[</span><span class="kt">Sum</span><span class="o">].</span><span class="py">leftOp</span><span class="o">)</span> <span class="o">+</span>
		<span class="nf">eval</span><span class="o">(</span><span class="nv">e</span><span class="o">.</span><span class="py">InstanceOf</span><span class="o">[</span><span class="kt">Sum</span><span class="o">].</span><span class="py">rightOp</span><span class="o">)</span>
	<span class="k">else</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Unkown expression "</span> <span class="o">+</span> <span class="n">e</span><span class="o">)</span>
</code></pre></div></div>

<p>A better solution would be to move the <code class="language-plaintext highlighter-rouge">eval</code> to each class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Expr</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">e1</span><span class="o">.</span><span class="py">eval</span> <span class="o">+</span> <span class="nv">e2</span><span class="o">.</span><span class="py">eval</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But this still has problems due to the limits of object oriented decomposition:</p>

<ul>
  <li>We have to implement a new method for every class</li>
  <li>We can only write methods local to a single class e.g. we canâ€™t implement the simplification rule ab + ac = a(b + c)</li>
</ul>

<h3 id="pattern-matching">Pattern Matching</h3>

<p>Notice that the purpose of test and accessor functions is to recover the construction process. For instance, when we create <code class="language-plaintext highlighter-rouge">new Sum(e1, e2)</code>, test functions check for the subclass created (<code class="language-plaintext highlighter-rouge">Sum</code>) and accessor functions check for the arguments passed (<code class="language-plaintext highlighter-rouge">e1, e2</code>).</p>

<p>Scala automates this process by use of <em>pattern matching</em>, which is switch statement built for hierarchies. Patterns can be any combination of:</p>

<ul>
  <li>constructors e.g. <code class="language-plaintext highlighter-rouge">Number, Sum</code></li>
  <li>variables, must start with a lowercase letter and only appear once per pattern e.g. <code class="language-plaintext highlighter-rouge">n, e1, e2</code></li>
  <li>wildcard patterns e.g. <code class="language-plaintext highlighter-rouge">Number(_)</code></li>
  <li>constants, must either be a literal or start with an uppercase letter e.g. <code class="language-plaintext highlighter-rouge">1, true, "abc", PI</code></li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Expr</span> <span class="o">{</span>
	<span class="c1">// Now we can pull out the construction args using pattern matching</span>
	<span class="c1">// This eval only deals with Number and Sum</span>
	<span class="k">def</span> <span class="nf">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span>
		<span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">e1</span><span class="o">.</span><span class="py">eval</span> <span class="o">+</span> <span class="nv">e2</span><span class="o">.</span><span class="py">eval</span>
		<span class="c1">// MatchError exception if no pattern matches e</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Prod</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>

<span class="c1">// the case keyword automatically creates these companion objects</span>
<span class="k">object</span> <span class="nc">Number</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="c1">// Number(1) === new Number(1)</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Sum</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Var</span> <span class="c1">// ...</span>
<span class="k">object</span> <span class="nc">Prod</span> <span class="c1">// ...</span>

<span class="c1">// Let's see an example evaluation of eval</span>
<span class="nc">Sum</span><span class="o">(</span><span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">eval</span>
<span class="o">===</span> <span class="nc">Sum</span><span class="o">(</span><span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span>
	<span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">e1</span><span class="o">.</span><span class="py">eval</span> <span class="o">+</span> <span class="nv">e2</span><span class="o">.</span><span class="py">eval</span>
<span class="o">}</span>
<span class="o">===</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="py">eval</span> <span class="o">+</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">eval</span>
<span class="o">===</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span>
	<span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">e1</span><span class="o">.</span><span class="py">eval</span> <span class="o">+</span> <span class="nv">e2</span><span class="o">.</span><span class="py">eval</span>
<span class="o">}</span> <span class="o">+</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">eval</span>
<span class="o">===</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">eval</span>
<span class="o">===</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span>
	<span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">e1</span><span class="o">.</span><span class="py">eval</span> <span class="o">+</span> <span class="nv">e2</span><span class="o">.</span><span class="py">eval</span>
<span class="o">}</span>
<span class="o">===</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="o">===</span> <span class="mi">3</span>

<span class="c1">// We can use pattern matching inside or outside of classes</span>
<span class="k">def</span> <span class="nf">show</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">sumBrackets</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">ex</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"("</span> <span class="o">+</span> <span class="nf">show</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="o">+</span> <span class="s">")"</span>
		<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nf">show</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="c1">// default</span>
	<span class="o">}</span>

	<span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">n</span><span class="o">.</span><span class="py">toString</span>
		<span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">show</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" + "</span> <span class="o">+</span> <span class="nf">show</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">Prod</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">sumBrackets</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" * "</span> <span class="o">+</span> <span class="nf">sumBrackets</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span>
		<span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="lists">Lists</h3>

<p>There are two important differences between arrays and lists:</p>

<ul>
  <li>Lists are immutable</li>
  <li>
    <p>Lists are recursive (think cons lists), while arrays are flat</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">)</span>
<span class="cm">/*
l is a cons list:
[]
| \
a  []
   | \
	 b  []
      | \
      c  Nil
*/</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>All lists are constructed from the empty list <code class="language-plaintext highlighter-rouge">Nil</code> and the <em>cons</em>truction operation <code class="language-plaintext highlighter-rouge">::</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">l</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="s">"a"</span> <span class="o">::</span> <span class="o">(</span><span class="s">"b"</span> <span class="o">::</span> <span class="o">(</span><span class="s">"c"</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span>
<span class="n">l</span> <span class="o">===</span> <span class="n">m</span>
<span class="c1">// all operators ending in : associate to the right</span>
<span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="s">"a"</span> <span class="o">::</span> <span class="s">"b"</span> <span class="o">::</span> <span class="s">"c"</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="n">l</span> <span class="o">===</span> <span class="n">m</span> <span class="o">===</span> <span class="n">n</span>
<span class="c1">// all operators ending in : are seen as method calls of the right hand operand</span>
<span class="k">val</span> <span class="nv">o</span> <span class="k">=</span> <span class="nc">Nil</span><span class="o">.::(</span><span class="mi">4</span><span class="o">).::(</span><span class="mi">3</span><span class="o">).::(</span><span class="mi">2</span><span class="o">).::(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">l</span> <span class="o">===</span> <span class="n">l</span> <span class="o">===</span> <span class="n">n</span> <span class="o">===</span> <span class="n">o</span>
<span class="c1">// so :: can be thought of as a prepend method</span>
</code></pre></div></div>

<p>All operations on lists can be expressed in terms of the following 3 operations:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">head</code> â‡’ the first element of the list</li>
  <li><code class="language-plaintext highlighter-rouge">tail</code> â‡’ the list composed of all elements except the first</li>
  <li><code class="language-plaintext highlighter-rouge">isEmpty</code> â‡’ true if the list is empty, false otherwise</li>
</ul>

<p>We can decompose lists with pattern matching. Some examples of valid patterns:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Nil</code> â‡’ the empty list</li>
  <li><code class="language-plaintext highlighter-rouge">p :: ps</code> â‡’ the list with head <code class="language-plaintext highlighter-rouge">p</code> and tail <code class="language-plaintext highlighter-rouge">ps</code>, where <code class="language-plaintext highlighter-rouge">ps</code> can be <code class="language-plaintext highlighter-rouge">Nil</code></li>
  <li><code class="language-plaintext highlighter-rouge">List(p1, ... pn)</code> â‡’ the list with head <code class="language-plaintext highlighter-rouge">p1</code> ending with element <code class="language-plaintext highlighter-rouge">pn</code></li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Insertion sort</span>
<span class="k">def</span> <span class="nf">isort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
	<span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="nf">insert</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="nf">isort</span><span class="o">(</span><span class="n">ys</span><span class="o">))</span>
<span class="o">}</span>
<span class="k">def</span> <span class="nf">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
	<span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="week-5">Week 5</h1>

<h3 id="more-functions-on-lists">More Functions on Lists</h3>

<p>Useful methods for <code class="language-plaintext highlighter-rouge">List</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xs.length</code> â‡’ the number of elements of <code class="language-plaintext highlighter-rouge">xs</code></li>
  <li><code class="language-plaintext highlighter-rouge">xs.last</code> â‡’ the listâ€™s last element, exception if <code class="language-plaintext highlighter-rouge">xs</code> is empty</li>
  <li><code class="language-plaintext highlighter-rouge">xs.init</code> â‡’ all the elements of <code class="language-plaintext highlighter-rouge">xs</code> except the last, exception if <code class="language-plaintext highlighter-rouge">xs</code> is empty</li>
  <li><code class="language-plaintext highlighter-rouge">xs take n</code> â‡’ first <code class="language-plaintext highlighter-rouge">n</code> elements of <code class="language-plaintext highlighter-rouge">xs</code>, or <code class="language-plaintext highlighter-rouge">xs</code> if <code class="language-plaintext highlighter-rouge">xs</code> has length less than <code class="language-plaintext highlighter-rouge">n</code></li>
  <li><code class="language-plaintext highlighter-rouge">xs drop n</code> â‡’ rest of <code class="language-plaintext highlighter-rouge">xs</code> after taking <code class="language-plaintext highlighter-rouge">n</code> elements</li>
  <li><code class="language-plaintext highlighter-rouge">xs(n) === xs.apply(n)</code> â‡’ the element of <code class="language-plaintext highlighter-rouge">xs</code> at index <code class="language-plaintext highlighter-rouge">n</code></li>
  <li><code class="language-plaintext highlighter-rouge">xs ++ ys === xs ::: ys === ys.:::(xs)</code> â‡’ the list <code class="language-plaintext highlighter-rouge">xs</code> concatenated with the list <code class="language-plaintext highlighter-rouge">ys</code></li>
  <li><code class="language-plaintext highlighter-rouge">xs.reverse</code> â‡’ the list <code class="language-plaintext highlighter-rouge">xs</code> in reverse order</li>
  <li><code class="language-plaintext highlighter-rouge">xs.updated(n, x)</code> â‡’ the list <code class="language-plaintext highlighter-rouge">xs</code> with the element at index <code class="language-plaintext highlighter-rouge">n</code> replaced by <code class="language-plaintext highlighter-rouge">x</code></li>
  <li><code class="language-plaintext highlighter-rouge">xs indexOf x</code> â‡’ the index of the first element in <code class="language-plaintext highlighter-rouge">xs</code> equal to <code class="language-plaintext highlighter-rouge">x</code>, or <code class="language-plaintext highlighter-rouge">-1</code> if not found</li>
  <li><code class="language-plaintext highlighter-rouge">xs contains x</code> â‡’ true if <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">xs</code>, false otherwise</li>
</ul>

<p>Letâ€™s analyze the complexity of some of these methods by writing possible implementations.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// O(N)</span>
<span class="k">def</span> <span class="nf">last</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"last of empty list"</span><span class="o">)</span>
	<span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
	<span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="nf">last</span><span class="o">(</span><span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// O(N)</span>
<span class="k">def</span> <span class="nf">init</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"init of empty list"</span><span class="o">)</span>
	<span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
	<span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">init</span><span class="o">(</span><span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// O(|xs|)</span>
<span class="k">def</span> <span class="nf">concat</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">ys</span>
	<span class="k">case</span> <span class="n">z</span> <span class="o">::</span> <span class="n">zs</span> <span class="k">=&gt;</span> <span class="n">z</span> <span class="o">::</span> <span class="nf">concat</span><span class="o">(</span><span class="n">zs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// O(N^2) =&gt; reverse(ys) takes 1 + 2 + ... + N = O(N) steps, and we iterate N times</span>
<span class="k">def</span> <span class="nf">reverse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
	<span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">ys</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">removeAt</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span> <span class="n">take</span> <span class="n">n</span><span class="o">)</span> <span class="o">:::</span> <span class="o">(</span><span class="n">xs</span> <span class="n">drop</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">flatten</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span> <span class="o">{</span>
	<span class="nf">case</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">ls</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">:::</span> <span class="nf">flatten</span><span class="o">(</span><span class="n">ls</span><span class="o">)</span>
	<span class="nf">case</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="pairs-and-tuples">Pairs and Tuples</h3>

<p>Letâ€™s see a more efficient sort than insertion sort, merge sort, to illustrate tuples.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// O(NlogN)</span>
<span class="k">def</span> <span class="nf">mergesort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
	<span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
	<span class="k">else</span> <span class="o">{</span>
		<span class="c1">// O(N) merge</span>
		<span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
			<span class="nf">case</span> <span class="o">(</span><span class="nc">List</span><span class="o">(),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
			<span class="nf">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">List</span><span class="o">())</span> <span class="k">=&gt;</span> <span class="n">xs</span>
			<span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xt</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">yt</span><span class="o">)</span> <span class="k">=&gt;</span>
				<span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xt</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
				<span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">yt</span><span class="o">)</span>
		<span class="o">}</span>
		<span class="c1">// tuple pattern binding</span>
		<span class="nf">val</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
		<span class="nf">merge</span><span class="o">(</span><span class="nf">mergesort</span><span class="o">(</span><span class="n">fst</span><span class="o">),</span> <span class="nf">mergesort</span><span class="o">(</span><span class="n">snd</span><span class="o">))</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="implicit-parameters">Implicit Parameters</h3>

<p>Letâ€™s parameterize <code class="language-plaintext highlighter-rouge">mergesort</code> so that it can be used with any type <code class="language-plaintext highlighter-rouge">T</code> . Weâ€™ll need to pass a comparison function for <code class="language-plaintext highlighter-rouge">T</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pass a less than function</span>
<span class="k">def</span> <span class="nf">mergesort</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">lt</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
	<span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
	<span class="k">else</span> <span class="o">{</span>
		<span class="c1">// O(N) merge</span>
		<span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
			<span class="nf">case</span> <span class="o">(</span><span class="nc">List</span><span class="o">(),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
			<span class="nf">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">List</span><span class="o">())</span> <span class="k">=&gt;</span> <span class="n">xs</span>
			<span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xt</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">yt</span><span class="o">)</span> <span class="k">=&gt;</span>
				<span class="nf">if</span> <span class="o">(</span><span class="nf">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xt</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
				<span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">yt</span><span class="o">)</span>
		<span class="o">}</span>
		<span class="c1">// tuple pattern binding</span>
		<span class="nf">val</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
		<span class="nf">merge</span><span class="o">(</span><span class="nf">mergesort</span><span class="o">(</span><span class="n">fst</span><span class="o">)(</span><span class="n">lt</span><span class="o">),</span> <span class="nf">mergesort</span><span class="o">(</span><span class="n">snd</span><span class="o">)(</span><span class="n">lt</span><span class="o">))</span>
	<span class="o">}</span>

<span class="k">val</span> <span class="nv">nums</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">fruits</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">)</span>
<span class="c1">// we could leave out type in anonymous comparison functions</span>
<span class="nf">mergesort</span><span class="o">(</span><span class="n">nums</span><span class="o">)((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span>
<span class="nf">mergesort</span><span class="o">(</span><span class="n">fruits</span><span class="o">)((</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">x</span><span class="o">.</span><span class="py">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div></div>

<p>Instead of writing our own, we could instead use <code class="language-plaintext highlighter-rouge">scala.math.Ordering[T]</code>. This allows us to use the <code class="language-plaintext highlighter-rouge">implicit</code> keyword, which makes the compiler automatically find an implicit ordering definition which:</p>

<ul>
  <li>is marked <code class="language-plaintext highlighter-rouge">implicit</code></li>
  <li>has a type compatible with <code class="language-plaintext highlighter-rouge">T</code></li>
  <li>is visible to the function or is defined in a companion object of <code class="language-plaintext highlighter-rouge">T</code></li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">math.Ordering</span>

<span class="k">def</span> <span class="nf">mergesort</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
	<span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
	<span class="k">else</span> <span class="o">{</span>
		<span class="c1">// O(N) merge</span>
		<span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
			<span class="nf">case</span> <span class="o">(</span><span class="nc">List</span><span class="o">(),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
			<span class="nf">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">List</span><span class="o">())</span> <span class="k">=&gt;</span> <span class="n">xs</span>
			<span class="nf">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xt</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">yt</span><span class="o">)</span> <span class="k">=&gt;</span>
				<span class="nf">if</span> <span class="o">(</span><span class="nv">ord</span><span class="o">.</span><span class="py">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xt</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
				<span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">yt</span><span class="o">)</span>
		<span class="o">}</span>
		<span class="c1">// tuple pattern binding</span>
		<span class="nf">val</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
		<span class="c1">// since we have implicit ord, we don't need to pass ord</span>
		<span class="nf">merge</span><span class="o">(</span><span class="nf">mergesort</span><span class="o">(</span><span class="n">fst</span><span class="o">),</span> <span class="nf">mergesort</span><span class="o">(</span><span class="n">snd</span><span class="o">))</span>
	<span class="o">}</span>

<span class="k">val</span> <span class="nv">nums</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">fruits</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">)</span>

<span class="nf">mergesort</span><span class="o">(</span><span class="n">nums</span><span class="o">)(</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span><span class="o">)</span>
<span class="nf">mergesort</span><span class="o">(</span><span class="n">fruits</span><span class="o">)(</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">String</span><span class="o">)</span>

<span class="c1">// implicit keyword means that compiler finds the correct ordering based on type</span>
<span class="nf">mergesort</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
<span class="nf">mergesort</span><span class="o">(</span><span class="n">fruits</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="higher-order-list-functions">Higher Order List Functions</h3>

<p>Common operations on lists:</p>

<ul>
  <li>transforming each element in a certain way</li>
  <li>filtering the list based on some criterion e.g.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">xs filter p</code> â‡’ all elements of <code class="language-plaintext highlighter-rouge">xs</code> satisfying <code class="language-plaintext highlighter-rouge">p</code></li>
      <li><code class="language-plaintext highlighter-rouge">xs filterNot p</code> â‡’ all elements of <code class="language-plaintext highlighter-rouge">xs</code> satisfying <code class="language-plaintext highlighter-rouge">!p</code></li>
      <li><code class="language-plaintext highlighter-rouge">xs partition p</code> â‡’ the pair <code class="language-plaintext highlighter-rouge">(xs filter p, xs filterNot p)</code></li>
      <li><code class="language-plaintext highlighter-rouge">xs takeWhile p</code> â‡’ the longest prefix of <code class="language-plaintext highlighter-rouge">xs</code> consisting of elements that satisfy <code class="language-plaintext highlighter-rouge">p</code></li>
      <li><code class="language-plaintext highlighter-rouge">xs dropWhile p</code> â‡’ the remainder of <code class="language-plaintext highlighter-rouge">xs</code> without any leading elements satisfying <code class="language-plaintext highlighter-rouge">p</code></li>
      <li><code class="language-plaintext highlighter-rouge">xs span p</code> â‡’ the pair <code class="language-plaintext highlighter-rouge">(xs takeWhile p, xs dropWhile p)</code></li>
    </ul>
  </li>
  <li>combining the elements of the list using some operator</li>
</ul>

<p>Letâ€™s write (simplified) generic versions of these operations.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
	<span class="c1">// Real implementations of these are more complex</span>
	<span class="c1">// They would be tail recursive and work on other collections</span>

	<span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="k">this</span>
		<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">::</span> <span class="nv">xs</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
	<span class="o">}</span>

	<span class="k">def</span> <span class="nf">filter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="k">this</span>
		<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">p</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="nv">xs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="k">else</span> <span class="nv">xs</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
	<span class="o">}</span>

	<span class="k">def</span> <span class="nf">reduceLeft</span><span class="o">(</span><span class="n">op</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Nil.reduceLeft"</span><span class="o">)</span>
		<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">xs</span> <span class="n">foldLeft</span> <span class="n">x</span><span class="o">)(</span><span class="n">op</span><span class="o">)</span> <span class="c1">// acc is the first element, x</span>
	<span class="o">}</span>

	<span class="c1">// apply op and fold into z for x1, x2 ... xN</span>
	<span class="k">def</span> <span class="nf">foldLeft</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">U</span><span class="o">)(</span><span class="n">op</span><span class="k">:</span> <span class="o">(</span><span class="kt">U</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">z</span>
		<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">xs</span> <span class="n">foldLeft</span> <span class="nf">op</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">x</span><span class="o">))(</span><span class="n">op</span><span class="o">)</span>
	<span class="o">}</span>

	<span class="k">def</span> <span class="nf">reduceRight</span><span class="o">(</span><span class="n">op</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Nil.reduceRight"</span><span class="o">)</span>
		<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">x</span>
		<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="nf">op</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nv">xs</span><span class="o">.</span><span class="py">reduceRight</span><span class="o">(</span><span class="n">op</span><span class="o">))</span>
	<span class="o">}</span>

	<span class="c1">// apply op and fold into z for xN,... x2, x1</span>
	<span class="k">def</span> <span class="nf">foldRight</span><span class="o">[</span><span class="kt">U</span><span class="o">][</span><span class="kt">x:</span> <span class="kt">U</span><span class="o">](</span><span class="n">op</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
		<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">z</span>
		<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="nf">op</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">xs</span> <span class="n">foldRight</span> <span class="n">z</span><span class="o">)(</span><span class="n">op</span><span class="o">))</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// We can use generic functions in other functions like this:</span>
<span class="k">def</span> <span class="nf">scaleList</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">factor</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
	<span class="n">xs</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factor</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">squareList</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
	<span class="n">xs</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">posElems</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
	<span class="n">xs</span> <span class="nf">filter</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>

<span class="c1">// we can't put foldLeft here because we can only apply :: on List(T)</span>
<span class="k">def</span> <span class="nf">concat</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
	<span class="o">(</span><span class="n">xs</span> <span class="n">foldRight</span> <span class="n">ys</span><span class="o">)(</span><span class="k">_</span> <span class="o">::</span> <span class="k">_</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">mapFun</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">xs</span> <span class="n">foldRight</span> <span class="nc">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]())((</span><span class="n">x</span><span class="o">,</span> <span class="n">acc</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">::</span> <span class="n">acc</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">lengthFun</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">xs</span> <span class="n">foldRight</span> <span class="mi">0</span><span class="o">)(</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">acc</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">acc</span> <span class="o">)</span>
</code></pre></div></div>

<p>As an exercise, letâ€™s write a function <code class="language-plaintext highlighter-rouge">pack</code> that packs consecutive duplicates of list elements into sublists. Then, letâ€™s use <code class="language-plaintext highlighter-rouge">pack</code> to write <code class="language-plaintext highlighter-rouge">encode</code>, which returns the run length encoding of a list.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pack</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
	<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xt</span> <span class="k">=&gt;</span> <span class="o">{</span>
		<span class="nf">val</span> <span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">remainder</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="nf">span</span> <span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span>
		<span class="n">prefix</span> <span class="o">::</span> <span class="nf">pack</span><span class="o">(</span><span class="n">remainder</span><span class="o">)</span>
	<span class="o">}</span>

<span class="k">val</span> <span class="nv">data</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">)</span>
<span class="nf">pack</span><span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="c1">// List(List("a", "a", "a"), List("b"), List("c", "c"), List("a"))</span>

<span class="k">def</span> <span class="nf">encode</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">Int</span><span class="o">)</span> <span class="kt">=</span>
	<span class="kt">pack</span><span class="o">(</span><span class="kt">xs</span><span class="o">)</span><span class="kt">.map</span><span class="o">(</span><span class="kt">ys</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="kt">ys.head</span>, <span class="kt">ys.length</span><span class="o">))</span>

<span class="kt">encode</span><span class="o">(</span><span class="kt">data</span><span class="o">)</span> <span class="kt">//</span> <span class="kt">List</span><span class="o">((</span><span class="kt">a</span>, <span class="err">3</span><span class="o">)</span>, <span class="o">(</span><span class="kt">b</span>, <span class="err">1</span><span class="o">)</span>, <span class="o">(</span><span class="kt">c</span>, <span class="err">2</span><span class="o">)</span>, <span class="o">(</span><span class="kt">a</span>, <span class="err">1</span><span class="o">))</span>
</code></pre></div></div>

<p>Weâ€™d like to prove that <code class="language-plaintext highlighter-rouge">concat</code> satisfies the following properties through <em>structural induction</em>:</p>

<ul>
  <li>associative â‡’ <code class="language-plaintext highlighter-rouge">(xs ++ ys) ++ zs === xs ++ (ys ++ zs)</code></li>
  <li>admits <code class="language-plaintext highlighter-rouge">Nil</code> as a neutral element to the left and right of a list â‡’ <code class="language-plaintext highlighter-rouge">xs ++ Nil === xs === Nil ++ xs</code></li>
</ul>

<p>Recall <em>natural induction</em> consists of a base case and a induction step. For example, to show a property P(n) for all integers n â‰¥ b, we must:</p>

<ul>
  <li>Show P(b)</li>
  <li>Show that for all integers n â‰¥ b, if P(n) then P(n + 1)</li>
</ul>

<p>referential transparency â‡’ a term is equivalent to the term to which it reduces, holds in pure functional programming since there are no side effects</p>

<p>Structural induction has a similar structure to natural induction. To prove a property P(<code class="language-plaintext highlighter-rouge">xs</code>) holds for all lists <code class="language-plaintext highlighter-rouge">xs</code>:</p>

<ul>
  <li>Show P(<code class="language-plaintext highlighter-rouge">Nil</code>)</li>
  <li>Show that for a list <code class="language-plaintext highlighter-rouge">xs</code> and some element <code class="language-plaintext highlighter-rouge">x</code>, if P(<code class="language-plaintext highlighter-rouge">xs</code>) then P(<code class="language-plaintext highlighter-rouge">x :: xs</code>)</li>
</ul>

<p>Letâ€™s prove that <code class="language-plaintext highlighter-rouge">concat</code> is associative first. Recall the definition of <code class="language-plaintext highlighter-rouge">concat</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">concat</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">ys</span>
	<span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xt</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="nf">concat</span><span class="o">(</span><span class="n">xt</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>From the implementation of concat, we can see 2 <em>defining clauses</em>:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Nil ++ ys === ys</code></li>
  <li><code class="language-plaintext highlighter-rouge">(x :: xt) ++ ys === x :: (xt ++ ys)</code></li>
</ol>

<p>Recall that the definition of association is <code class="language-plaintext highlighter-rouge">(xs ++ ys) ++ zs === xs ++ (ys ++ zs)</code>. For the base case, <code class="language-plaintext highlighter-rouge">xs = Nil</code>. Letâ€™s simplify using our first defining clause to see that association holds in the <code class="language-plaintext highlighter-rouge">Nil</code> case.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="n">zs</span> <span class="o">===</span> <span class="o">(</span><span class="nc">Nil</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="n">zs</span> <span class="c1">// by 1st defining clause</span>
	<span class="o">===</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">zs</span>
<span class="n">xs</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">)</span> <span class="o">===</span> <span class="nc">Nil</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">)</span> <span class="c1">// by 1st defining clause</span>
	<span class="o">===</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">zs</span>

<span class="c1">// thus, for xs =&gt; Nil,</span>
<span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="n">zs</span> <span class="o">===</span> <span class="n">xs</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">)</span>
</code></pre></div></div>

<p>Now letâ€™s prove association in the induction step, <code class="language-plaintext highlighter-rouge">x :: xs</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="n">zs</span> <span class="o">===</span> <span class="o">((</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="n">zs</span>
	<span class="o">===</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">))</span> <span class="o">++</span> <span class="n">zs</span> <span class="c1">// by 2nd defining clause</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="o">((</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="n">zs</span><span class="o">))</span> <span class="c1">// by 2nd defining clause</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">))</span> <span class="c1">// by induction hypothesis</span>

<span class="n">xs</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">)</span> <span class="o">===</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">)</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">))</span> <span class="c1">// by 2nd defining clause</span>

<span class="c1">// thus, for xs =&gt; x :: xs,</span>
<span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="n">zs</span> <span class="o">===</span> <span class="n">xs</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span><span class="o">)</span>
</code></pre></div></div>

<p>Thus, we have proven association on <code class="language-plaintext highlighter-rouge">concat</code> by structural induction.</p>

<p>Next, letâ€™s prove that <code class="language-plaintext highlighter-rouge">concat</code> admits <code class="language-plaintext highlighter-rouge">Nil</code> as a neutral element on the right, meaning that <code class="language-plaintext highlighter-rouge">xs ++ Nil === xs</code>.</p>

<p>For the base case, <code class="language-plaintext highlighter-rouge">xs =&gt; Nil</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xs</span> <span class="o">++</span> <span class="nc">Nil</span> <span class="o">===</span> <span class="nc">Nil</span> <span class="o">++</span> <span class="nc">Nil</span>
	<span class="o">===</span> <span class="nc">Nil</span> <span class="c1">// by 1st defining clause</span>
	<span class="o">===</span> <span class="n">xs</span>
</code></pre></div></div>

<p>For the induction step, <code class="language-plaintext highlighter-rouge">xs =&gt; x :: xs</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Nil</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="nc">Nil</span><span class="o">)</span> <span class="c1">// by 2nd defining clause</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="c1">// by induction hypothesis</span>
</code></pre></div></div>

<p>Letâ€™s now see a more complex proof, for the reverse function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reverse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
	<span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="nf">reverse</span><span class="o">(</span><span class="n">ys</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We see the 2 following defining clauses:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Nil.reverse = Nil</code></li>
  <li><code class="language-plaintext highlighter-rouge">(x :: xs).reverse = xs.reverse ++ List(x)</code></li>
</ol>

<p>Weâ€™d like to prove that <code class="language-plaintext highlighter-rouge">xs.reverse.reverse = xs</code>.</p>

<p>For the base case, <code class="language-plaintext highlighter-rouge">xs =&gt; Nil</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Nil</span><span class="o">.</span><span class="py">reverse</span><span class="o">.</span><span class="py">reverse</span>
	<span class="o">===</span> <span class="nv">Nil</span><span class="o">.</span><span class="py">reverse</span>
	<span class="o">===</span> <span class="nc">Nil</span>
</code></pre></div></div>

<p>For the induction step, <code class="language-plaintext highlighter-rouge">xs =&gt; x :: xs</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">).</span><span class="py">reverse</span><span class="o">.</span><span class="py">reverse</span>
	<span class="o">===</span> <span class="o">(</span><span class="nv">xs</span><span class="o">.</span><span class="py">reverse</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)).</span><span class="py">reverse</span>
<span class="c1">// Let ys =&gt; xs.reverse</span>
	<span class="o">===</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)).</span><span class="py">reverse</span>

<span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="nv">xs</span><span class="o">.</span><span class="py">reverse</span><span class="o">.</span><span class="py">reverse</span> <span class="c1">// by induction hypothesis</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="nv">ys</span><span class="o">.</span><span class="py">reverse</span>

<span class="c1">// Let's now do structural induction on ys, to prove</span>
<span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)).</span><span class="py">reverse</span> <span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="nv">ys</span><span class="o">.</span><span class="py">reverse</span>

<span class="c1">// Base case: ys =&gt; Nil</span>
<span class="o">(</span><span class="nc">Nil</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)).</span><span class="py">reverse</span>
	<span class="o">===</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="py">reverse</span> <span class="c1">// 1st clause of ++</span>
	<span class="o">===</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">).</span><span class="py">reverse</span> <span class="c1">// definition of List</span>
	<span class="o">===</span> <span class="nv">Nil</span><span class="o">.</span><span class="py">reverse</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// 2nd clause of reverse</span>
	<span class="o">===</span> <span class="nc">Nil</span> <span class="o">++</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="c1">// 1st clause of reverse, definition of list</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="c1">// 1st clause of ++</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="nv">Nil</span><span class="o">.</span><span class="py">reverse</span> <span class="c1">// 1st clause of reverse</span>

<span class="c1">// Induction step: ys =&gt; y :: ys</span>
<span class="o">((</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys</span><span class="o">)</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)).</span><span class="py">reverse</span>
	<span class="o">===</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">))).</span><span class="py">reverse</span> <span class="c1">// 2nd clause of ++</span>
	<span class="o">===</span> <span class="o">(</span><span class="n">ys</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)).</span><span class="py">reverse</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="c1">// 2nd clause of reverse</span>
	<span class="o">===</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="nv">ys</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">y</span><span class="o">)</span> <span class="c1">// induction hypothesis</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="nv">ys</span><span class="o">.</span><span class="py">reverse</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="c1">// first clause of ++</span>
	<span class="o">===</span> <span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">ys</span><span class="o">).</span><span class="py">reverse</span> <span class="c1">// 2nd clause of reverse</span>
</code></pre></div></div>

<p>Letâ€™s now prove a distribution law for map over concatenation. For any lists <code class="language-plaintext highlighter-rouge">xs, ys</code> and function <code class="language-plaintext highlighter-rouge">f</code>, <code class="language-plaintext highlighter-rouge">(xs ++ ys) map f = (xs map f) ++ (ys map f)</code>.</p>

<p>Assume we have the following defining clauses for map:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Nil map f = Nil</code></li>
  <li><code class="language-plaintext highlighter-rouge">(x :: xs) map f = f(x) :: (xs map f)</code></li>
</ol>

<p>For the base case:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// xs =&gt; Nil</span>
<span class="o">(</span><span class="nc">Nil</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="n">map</span> <span class="n">f</span>
	<span class="o">===</span> <span class="n">ys</span> <span class="n">map</span> <span class="n">f</span> <span class="c1">// 1st clause of ++</span>
	<span class="o">===</span> <span class="nc">Nil</span> <span class="o">++</span> <span class="n">ys</span> <span class="n">map</span> <span class="n">f</span> <span class="c1">// by 1st clause of ++</span>
	<span class="o">===</span> <span class="o">(</span><span class="nc">Nil</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="o">++</span> <span class="n">ys</span> <span class="n">map</span> <span class="n">f</span> <span class="c1">// 1st clause of map</span>

<span class="c1">// ys =&gt; Nil</span>
<span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="nc">Nil</span><span class="o">)</span> <span class="n">map</span> <span class="n">f</span>
	<span class="o">===</span> <span class="n">xs</span> <span class="n">map</span> <span class="n">f</span>
	<span class="o">===</span> <span class="n">xs</span> <span class="n">map</span> <span class="n">f</span> <span class="o">++</span> <span class="nc">Nil</span>
	<span class="o">===</span> <span class="n">xs</span> <span class="n">map</span> <span class="n">f</span> <span class="o">++</span> <span class="nc">Nil</span> <span class="n">map</span> <span class="n">f</span>
</code></pre></div></div>

<p>For the induction step:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// xs =&gt; x :: xs</span>
<span class="o">((</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="n">map</span> <span class="n">f</span>
	<span class="o">===</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="o">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">))</span> <span class="n">map</span> <span class="n">f</span> <span class="c1">// 2nd clause of ++</span>
	<span class="o">===</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">::</span> <span class="o">((</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="o">)</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="c1">// 2nd clause of map</span>
	<span class="o">===</span> <span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">::</span> <span class="o">((</span><span class="n">xs</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span> <span class="c1">// induction hypothesis</span>
	<span class="o">===</span> <span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="n">xs</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="c1">// 2nd clause of ++</span>
	<span class="o">===</span> <span class="o">((</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="o">++</span> <span class="o">(</span><span class="n">ys</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span> <span class="c1">// 2nd clause of map</span>

<span class="c1">// ys =&gt; y :: ys ??? can't do this proof</span>
</code></pre></div></div>

<h1 id="week-6">Week 6</h1>

<h3 id="sequences">Sequences</h3>

<p><code class="language-plaintext highlighter-rouge">Vector</code> â‡’ an immutable data structure with a more evenly balanced access pattern than <code class="language-plaintext highlighter-rouge">List</code></p>

<ul>
  <li>For up to 32 elements, an <code class="language-plaintext highlighter-rouge">Array</code></li>
  <li>For more than 32 elements, a tree where each node is an <code class="language-plaintext highlighter-rouge">Array</code> with 32 pointers and each leaf is an <code class="language-plaintext highlighter-rouge">Array</code> with 32 elements</li>
</ul>

<p>Random access for a <code class="language-plaintext highlighter-rouge">Vector</code> is O(logN), since the depth of the <code class="language-plaintext highlighter-rouge">Vector</code> increases at logN. We pick 32 since 32 elements fits on a single cache line on most platforms, which gives us space/time locality for operations on elements in bulk e.g. map, filter, reduce.</p>

<p>Random access for <code class="language-plaintext highlighter-rouge">List</code> is O(N) and there are no guarantees on where the data for <code class="language-plaintext highlighter-rouge">List</code> objects will be stored on disk. So, we should prefer <code class="language-plaintext highlighter-rouge">List</code> to <code class="language-plaintext highlighter-rouge">Vector</code> when we need patterns of repeatedly accessing <code class="language-plaintext highlighter-rouge">head</code> and prefer <code class="language-plaintext highlighter-rouge">Vector</code> to <code class="language-plaintext highlighter-rouge">List</code> when doing bulk operations.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">nums</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">88</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">people</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">,</span> <span class="s">"James"</span><span class="o">,</span> <span class="s">"Peter"</span><span class="o">)</span>

<span class="c1">// Vectors support all List operations (both subclass Seq, Iterable)</span>
<span class="c1">// However, instead of x :: xs, vectors have:</span>
<span class="mi">0</span> <span class="o">+:</span> <span class="n">nums</span> <span class="c1">// Vector(0, 1, 2, 3, -88)</span>
<span class="n">people</span> <span class="o">:+</span> <span class="s">"Martin"</span> <span class="c1">// Vector("Bob", "James", "Peter", "Martin")</span>
</code></pre></div></div>

<p>Appending elements causes the relevant inner nodes in the <code class="language-plaintext highlighter-rouge">Vector</code> to be replaced, which is an O(logN) operation since the depth of the <code class="language-plaintext highlighter-rouge">Vector</code> increases at logN.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Arrays and Strings also support Seq operations, but do not subclass Seq</span>
<span class="c1">// since they come from Java</span>
<span class="k">val</span> <span class="nv">xs</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">44</span><span class="o">)</span>
<span class="n">xs</span> <span class="nf">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="s">"Hello World"</span>
<span class="n">s</span> <span class="nf">filter</span> <span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="nv">c</span><span class="o">.</span><span class="py">isUpper</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Range</code> â‡’ <code class="language-plaintext highlighter-rouge">Seq</code> of evenly spaced integers with operators <code class="language-plaintext highlighter-rouge">to</code> (inclusive), <code class="language-plaintext highlighter-rouge">until</code> (exclusive), and <code class="language-plaintext highlighter-rouge">by</code> (determines step value)</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Range only stores max, min, and step value</span>
<span class="k">val</span> <span class="nv">r</span><span class="k">:</span> <span class="kt">Range</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">5</span> <span class="c1">// 1, 2, 3, 4</span>
<span class="k">val</span> <span class="nv">s</span><span class="k">:</span> <span class="kt">Range</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span> <span class="c1">// 1, 2, 3, 4, 5</span>
<span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span> <span class="n">by</span> <span class="mi">3</span> <span class="c1">// 1, 4, 7, 10</span>
</code></pre></div></div>

<p>More sequence operations:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xs exists p</code> â‡’ true if there is some x in xs such that p(x) holds, else false</li>
  <li><code class="language-plaintext highlighter-rouge">xs forall p</code> â‡’ true if p(x) holds for all xs, else false</li>
  <li><code class="language-plaintext highlighter-rouge">xs zip ys</code> â‡’ sequence of pairs drawn from xs and ys until the shorter list is exhausted</li>
  <li><code class="language-plaintext highlighter-rouge">xs.unzip</code> â‡’ splits sequence of pairs <code class="language-plaintext highlighter-rouge">xs</code> into two sequences</li>
  <li><code class="language-plaintext highlighter-rouge">xs.flatMap f</code> â‡’ applies f to all elements of xs, concatenates, and then flattens</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="s">"Hello World"</span>
<span class="n">s</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="sc">'.'</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="c1">// ".H.e.l.l.o. .W.o.r.l.d"</span>

<span class="nv">s</span><span class="o">.</span><span class="py">flatten</span>
	<span class="o">====</span> <span class="n">s</span> <span class="n">foldRight</span> <span class="s">""</span><span class="o">)(</span><span class="k">_</span> <span class="o">++</span> <span class="k">_</span><span class="o">)</span>
	<span class="o">====</span> <span class="n">s</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xs.sum</code> â‡’ sum of all elements of the numeric list xs</li>
  <li><code class="language-plaintext highlighter-rouge">xs.product</code> â‡’ product of all elements of the numeric list xs</li>
  <li><code class="language-plaintext highlighter-rouge">xs.min</code> â‡’ minimum of xs (Ordering must exist)</li>
  <li><code class="language-plaintext highlighter-rouge">xs.max</code> â‡’ maximum of xs (Ordering must exist)</li>
</ul>

<h3 id="examples">Examples</h3>

<ol>
  <li>
    <p>Write a function to list all combinations of numbers x and y where x is drawn from the range 1 â€¦ M and y is drawn from the range 1 â€¦ N.</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">M</span><span class="o">)</span> <span class="nf">flatMap</span> <span class="o">(</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">N</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)))</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Compute the scalar product of two vectors</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scalarProduct</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
	<span class="o">(</span><span class="n">xs</span> <span class="n">zip</span> <span class="n">ys</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">xy</span> <span class="k">=&gt;</span> <span class="nv">xy</span><span class="o">.</span><span class="py">_1</span> <span class="o">*</span> <span class="nv">xy</span><span class="o">.</span><span class="py">_2</span><span class="o">).</span><span class="py">sum</span>

<span class="c1">// Or, use pattern matching</span>
<span class="k">def</span> <span class="nf">scalarProductPM</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
	<span class="o">(</span><span class="n">xs</span> <span class="n">zip</span> <span class="n">ys</span><span class="o">).</span><span class="py">map</span><span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">}.</span><span class="py">sum</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Write a high level way to test for primality of numbers.</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="mi">2</span> <span class="n">to</span> <span class="n">n</span><span class="o">)</span> <span class="nf">forall</span> <span class="o">(</span><span class="n">d</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Given a positive integer n, find all pairs of positive integers i and j, with 1 â‰¤ j &lt; i &lt; n such that i + j is prime.</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// generate all integers i between 1 and n</span>
<span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">n</span><span class="o">)</span> <span class="nf">flatMap</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span>
	<span class="c1">// generate the list of pairs (i, 1), (i, 2), ... (i, i - 1)</span>
	<span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="n">i</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)))</span>
<span class="c1">// produces a IndexedSequence: [(2, 1), (3, 1), (3, 2), ...]</span>
<span class="n">filter</span><span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div>    </div>

    <p>Letâ€™s now look to simplify this using the <code class="language-plaintext highlighter-rouge">for</code> expression, which produces a result list over iterations without side effects.</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// For example, these are equivalent</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span> <span class="k">if</span> <span class="nv">p</span><span class="o">.</span><span class="py">age</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="o">)</span> <span class="k">yield</span> <span class="nv">p</span><span class="o">.</span><span class="py">name</span>
<span class="o">===</span> <span class="n">persons</span> <span class="nf">filter</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="nv">p</span><span class="o">.</span><span class="py">age</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="nv">p</span><span class="o">.</span><span class="py">name</span><span class="o">)</span>
</code></pre></div>    </div>

    <p><code class="language-plaintext highlighter-rouge">for</code> expressions have the general form <code class="language-plaintext highlighter-rouge">for (p &lt;- c if f) yield e</code>:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">p &lt;- c</code> â‡’ generator where p is a pattern and c is a collection</li>
      <li><code class="language-plaintext highlighter-rouge">if f</code> â‡’ filter</li>
    </ul>

    <p><code class="language-plaintext highlighter-rouge">for</code> expressions can have multiple generators, where each sequential generator varies faster than the last.</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
	<span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">n</span>
	<span class="n">j</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">i</span>
	<span class="k">if</span> <span class="nf">isPrime</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Write a version of <code class="language-plaintext highlighter-rouge">scalarProduct</code> that makes use of a <code class="language-plaintext highlighter-rouge">for</code>.</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scalarProduct</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
	<span class="o">(</span><span class="nf">for</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">xs</span> <span class="n">zip</span> <span class="n">ys</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">).</span><span class="py">sum</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="sets">Sets</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Most operations on Sequences are also available on Sets</span>
<span class="k">val</span> <span class="nv">fruit</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">6</span><span class="o">).</span><span class="py">toSet</span>
</code></pre></div></div>

<p>Principal differences between <code class="language-plaintext highlighter-rouge">Set</code> and <code class="language-plaintext highlighter-rouge">Sequence</code>:</p>

<ul>
  <li>Sets are unordered</li>
  <li>Sets do not have duplicate elements</li>
  <li>The fundamental operation on sets is <code class="language-plaintext highlighter-rouge">contains</code></li>
</ul>

<p>Recall the N-Queens problem. We want to place N queens on a N by N chessboard such that no two queens are on the same row, column, or diagonal. Assume each solution is represented of a list of length N, where the index is the row of the queen and the value is column of the queen, and the queens are listed from the bottommost row up. We can solve this problem with a recursive algorithm.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">nqueens</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">queens</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
		<span class="k">def</span> <span class="nf">placeQueens</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
			<span class="nf">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Set</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
			<span class="k">else</span>
				<span class="k">for</span> <span class="o">{</span>
					<span class="n">queens</span> <span class="k">&lt;-</span> <span class="nf">placeQueens</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
					<span class="n">col</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">n</span>
					<span class="k">if</span> <span class="nf">isSafe</span><span class="o">(</span><span class="n">col</span><span class="o">,</span> <span class="n">queens</span><span class="o">)</span>
				<span class="o">}</span> <span class="k">yield</span> <span class="n">col</span> <span class="o">::</span> <span class="n">queens</span>
		<span class="nf">placeQueens</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
	<span class="o">}</span>

	<span class="k">def</span> <span class="nf">isSafe</span><span class="o">(</span><span class="n">col</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">queens</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span>
		<span class="k">val</span> <span class="nv">row</span> <span class="k">=</span> <span class="nv">queens</span><span class="o">.</span><span class="py">length</span>
		<span class="k">val</span> <span class="nv">queensWithRow</span> <span class="k">=</span> <span class="o">(</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">0</span> <span class="n">by</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">zip</span> <span class="n">queens</span>
		<span class="n">queensWithRow</span> <span class="n">forall</span> <span class="o">{</span>
			<span class="nf">case</span> <span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">col</span> <span class="o">!=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="nv">math</span><span class="o">.</span><span class="py">abs</span><span class="o">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="n">row</span> <span class="o">-</span> <span class="n">r</span>
		<span class="o">}</span>

	<span class="k">def</span> <span class="nf">show</span><span class="o">(</span><span class="n">queens</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
		<span class="k">val</span> <span class="nv">lines</span> <span class="k">=</span>
			<span class="nf">for</span> <span class="o">(</span><span class="n">col</span> <span class="k">&lt;-</span> <span class="nv">queens</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span>
			<span class="k">yield</span> <span class="nv">Vector</span><span class="o">.</span><span class="py">fill</span><span class="o">(</span><span class="nv">queens</span><span class="o">.</span><span class="py">length</span><span class="o">)(</span><span class="s">"* "</span><span class="o">).</span><span class="py">updated</span><span class="o">(</span><span class="n">col</span><span class="o">,</span> <span class="s">"X "</span><span class="o">).</span><span class="py">mkString</span>
		<span class="s">"\n"</span> <span class="o">+</span> <span class="o">(</span><span class="n">lines</span> <span class="n">mkString</span> <span class="s">"\n"</span><span class="o">)</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="maps">Maps</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">romanNumerals</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"I"</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">"V"</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="s">"X"</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">)</span> <span class="c1">// Map[String, Int]</span>
<span class="k">val</span> <span class="nv">capitalOfCountry</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"US"</span> <span class="o">-&gt;</span> <span class="s">"Washington"</span><span class="o">,</span> <span class="s">"Switzerland"</span> <span class="o">-&gt;</span> <span class="s">"Bern"</span><span class="o">)</span>

<span class="c1">// Maps are iterables, Map[K, V] extends Iterable[(K, V)]</span>
<span class="k">val</span> <span class="nv">countryOfCapital</span> <span class="k">=</span> <span class="n">capitalOfCountry</span> <span class="n">map</span> <span class="o">{</span>
	<span class="nf">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Maps are also functions, Map[K, V] extends K =&gt; V</span>
<span class="nf">capitalOfCountry</span><span class="o">(</span><span class="s">"US"</span><span class="o">)</span> <span class="c1">// "Washington"</span>
<span class="nf">capitalOfCountry</span><span class="o">(</span><span class="s">"Andorra"</span><span class="o">)</span> <span class="c1">// NoSuchElementException</span>
<span class="n">capitalOfCountry</span> <span class="n">get</span> <span class="s">"Andorra"</span> <span class="c1">// Option[String] = None</span>
<span class="n">captialOfCountry</span> <span class="n">get</span> <span class="s">"US"</span> <span class="c1">// Option[String] = Some("Washington")</span>

<span class="k">val</span> <span class="nv">capitals</span> <span class="k">=</span> <span class="n">capitalOfCountry</span> <span class="n">withDefaultValue</span> <span class="s">"unknown"</span>
<span class="nf">capitals</span><span class="o">(</span><span class="s">"Andorra"</span><span class="o">)</span> <span class="c1">// "unknown</span>

<span class="c1">// Option definition</span>
<span class="k">trait</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Some</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">extends</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">object</span> <span class="nc">None</span> <span class="k">extends</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Notion</span><span class="o">]</span>

<span class="c1">// Since Options are case classes, they can be pattern matched</span>
<span class="k">def</span> <span class="nf">showCapital</span><span class="o">(</span><span class="n">country</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nv">captialOfCountry</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">country</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
	<span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">capital</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">capital</span>
	<span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="s">"missing data"</span>
<span class="o">}</span>
<span class="c1">// Options also support map, filter, etc.</span>
</code></pre></div></div>

<p>Letâ€™s now look at <code class="language-plaintext highlighter-rouge">groupBy</code> and <code class="language-plaintext highlighter-rouge">orderBy</code>, which are two operations from SQL we can express in <code class="language-plaintext highlighter-rouge">for</code> expressions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// orderBy =&gt; sortWith and sorted</span>
<span class="k">val</span> <span class="nv">fruit</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"pear"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">,</span> <span class="s">"pineapple"</span><span class="o">)</span>
<span class="n">fruit</span> <span class="nf">sortWith</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">length</span> <span class="o">&lt;</span> <span class="nv">_</span><span class="o">.</span><span class="py">length</span><span class="o">)</span> <span class="c1">// sort by word length</span>
<span class="nv">fruit</span><span class="o">.</span><span class="py">sorted</span> <span class="c1">// lexographic</span>

<span class="c1">// groupBy</span>
<span class="n">fruit</span> <span class="nf">groupBy</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">head</span><span class="o">)</span>
<span class="c1">// Map("p" -&gt; List("pear", "pineapple"),</span>
<span class="c1">//     "a" -&gt; List("apple"),</span>
<span class="c1">//     "o" -&gt; List("orange"))</span>
</code></pre></div></div>

<p>Letâ€™s design a class <code class="language-plaintext highlighter-rouge">Poly</code> that represents a polynomial as a map from each exponent to its coefficient.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Poly</span><span class="o">(</span><span class="k">val</span> <span class="nv">terms0</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">])</span> <span class="o">{</span>
	<span class="c1">// allow us to pass a sequence for construction</span>
	<span class="k">def</span> <span class="nf">this</span><span class="o">(</span><span class="n">bindings</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Double</span><span class="o">)*)</span> <span class="k">=</span> <span class="nf">this</span><span class="o">(</span><span class="nv">bindings</span><span class="o">.</span><span class="py">toMap</span><span class="o">)</span>

	<span class="k">val</span> <span class="nv">terms</span> <span class="k">=</span> <span class="n">terms0</span> <span class="nf">withDefaultValue</span><span class="o">(</span><span class="mf">0.0</span><span class="o">)</span>

	<span class="c1">// When 2 maps are added, matching keys are overwritten in the first map</span>
	<span class="c1">// So, we need to adjust the second map</span>
	<span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Poly</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">(</span><span class="n">terms</span> <span class="o">++</span> <span class="o">(</span><span class="nv">other</span><span class="o">.</span><span class="py">terms</span> <span class="n">map</span> <span class="n">adjust</span><span class="o">))</span>
	<span class="k">def</span> <span class="nf">adjust</span><span class="o">(</span><span class="n">term</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Double</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
		<span class="nf">val</span> <span class="o">(</span><span class="n">exp</span><span class="o">,</span> <span class="n">coeff</span><span class="o">)</span> <span class="k">=</span> <span class="n">term</span>
		<span class="n">exp</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">coeff</span> <span class="o">+</span> <span class="nf">terms</span><span class="o">(</span><span class="n">exp</span><span class="o">))</span>
	<span class="o">}</span>

	<span class="c1">// An faster implementation using foldLeft since we don't have to</span>
	<span class="c1">// store an intermediate list of adjusted terms</span>
	<span class="k">def</span> <span class="nf">+</span> <span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Poly</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">((</span><span class="nv">other</span><span class="o">.</span><span class="py">terms</span> <span class="n">foldLeft</span> <span class="n">terms</span><span class="o">)(</span><span class="n">addTerm</span><span class="o">)</span>
	<span class="k">def</span> <span class="nf">addTerm</span><span class="o">(</span><span class="n">terms</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">],</span> <span class="n">term</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Double</span><span class="o">))</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
		<span class="nf">val</span> <span class="o">(</span><span class="n">exp</span><span class="o">,</span> <span class="n">coeff</span><span class="o">)</span> <span class="k">=</span> <span class="n">term</span>
		<span class="n">terms</span> <span class="o">+</span> <span class="n">exp</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">coeff</span> <span class="o">+</span> <span class="nf">terms</span><span class="o">(</span><span class="n">exp</span><span class="o">))</span>
	<span class="o">}</span>

	<span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span> <span class="k">=</span>
		<span class="o">(</span><span class="nf">for</span> <span class="o">((</span><span class="n">exp</span><span class="o">,</span> <span class="n">coeff</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nv">terms</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">sorted</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span>
				<span class="k">yield</span> <span class="n">coeff</span> <span class="o">+</span> <span class="s">"x^"</span> <span class="o">+</span> <span class="n">exp</span>
		<span class="o">)</span> <span class="n">mkString</span> <span class="s">" + "</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">p1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mf">4.0</span><span class="o">,</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="mf">6.2</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">p2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Poly</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mf">3.0</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mf">7.0</span><span class="o">))</span>
<span class="n">p1</span> <span class="o">+</span> <span class="n">p2</span>

<span class="nv">p1</span><span class="o">.</span><span class="py">terms</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span> <span class="c1">// 0.0</span>
</code></pre></div></div>

<p>Letâ€™s now see a larger example. Phone keys have mnemonics assigned to them:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">mnem</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
	<span class="sc">'2'</span> <span class="o">-&gt;</span> <span class="s">"ABC"</span><span class="o">,</span> <span class="sc">'3'</span> <span class="o">-&gt;</span> <span class="s">"DEF"</span><span class="o">,</span> <span class="sc">'4'</span> <span class="o">-&gt;</span> <span class="s">"GHI"</span><span class="o">,</span> <span class="sc">'5'</span> <span class="o">-&gt;</span> <span class="s">"JKL"</span><span class="o">,</span> <span class="sc">'6'</span> <span class="o">-&gt;</span> <span class="s">"MNO"</span><span class="o">,</span>
	<span class="sc">'7'</span> <span class="o">-&gt;</span> <span class="s">"PQRS"</span><span class="o">,</span> <span class="sc">'8'</span> <span class="o">-&gt;</span> <span class="s">"TUV"</span><span class="o">,</span> <span class="sc">'9'</span> <span class="o">-&gt;</span> <span class="s">"WXYZ"</span>
<span class="o">)</span>
</code></pre></div></div>

<p>Design a method <code class="language-plaintext highlighter-rouge">translate(phoneNumber)</code> that produces all possible words that <code class="language-plaintext highlighter-rouge">phoneNumber</code> could represent.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">in</span> <span class="k">=</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromURL</span><span class="o">(...)</span> <span class="c1">// get dictionary from source</span>
<span class="k">val</span> <span class="nv">words</span> <span class="k">=</span> <span class="nv">in</span><span class="o">.</span><span class="py">getLines</span><span class="o">.</span><span class="py">toList</span> <span class="nf">filter</span> <span class="o">(</span><span class="n">w</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="nf">forall</span> <span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="nv">c</span><span class="o">.</span><span class="py">isLetter</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">mnem</span> <span class="k">=</span> <span class="o">...</span>

<span class="c1">// Invert the mnem map to give a map from chars A...Z to 2...9</span>
<span class="k">val</span> <span class="nv">charCode</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Char</span>, <span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nf">for</span><span class="o">((</span><span class="n">digit</span><span class="o">,</span> <span class="n">str</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">mnem</span><span class="o">;</span> <span class="n">l</span> <span class="k">&lt;-</span> <span class="n">str</span><span class="o">)</span> <span class="k">yield</span> <span class="n">ltr</span> <span class="o">-&gt;</span> <span class="n">digit</span>

<span class="c1">// Maps a word to the difit string it can represeng e.g. Java -&gt; 5282</span>
<span class="k">def</span> <span class="nf">wordCode</span><span class="o">(</span><span class="n">word</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nv">word</span><span class="o">.</span><span class="py">toUpperCase</span> <span class="n">map</span> <span class="n">charCode</span>

<span class="cm">/*
 * A map from digit strings to the words that represent them
 * e.g. 5282 -&gt; List("Java", "Kata", "Lava", ...)
 * Note: A missing number should map to the empty set e.g. "1111" -&gt; List()
*/</span>
<span class="k">val</span> <span class="nv">wordsForNum</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
	<span class="n">words</span> <span class="n">groupBy</span> <span class="n">wordCode</span> <span class="n">withDefaultValue</span> <span class="nc">Seq</span><span class="o">()</span>

<span class="c1">// Return all ways to encode a number as a list of words</span>
<span class="k">def</span> <span class="nf">encode</span><span class="o">(</span><span class="n">number</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
	<span class="nf">if</span> <span class="o">(</span><span class="nv">number</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="nc">Set</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
	<span class="k">else</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">{</span>
			<span class="n">split</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="nv">number</span><span class="o">.</span><span class="py">length</span>
			<span class="n">word</span> <span class="k">&lt;-</span> <span class="nf">wordsForNum</span><span class="o">(</span><span class="n">number</span> <span class="n">take</span> <span class="n">split</span><span class="o">)</span>
			<span class="n">rest</span> <span class="k">&lt;-</span> <span class="nf">encode</span><span class="o">(</span><span class="n">number</span> <span class="n">drop</span> <span class="n">split</span><span class="o">)</span>
		<span class="o">}</span> <span class="k">yield</span> <span class="n">word</span> <span class="o">::</span> <span class="n">rest</span>
	<span class="o">}.</span><span class="py">toSet</span>

<span class="c1">// Get phrases set</span>
<span class="k">def</span> <span class="nf">translate</span><span class="o">(</span><span class="n">number</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
	<span class="nf">encode</span><span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">mkString</span> <span class="s">" "</span><span class="o">)</span>
</code></pre></div></div>
</div><section class="article__sharing d-print-none"></section><div class="d-print-none"><footer class="article__footer"><meta itemprop="dateModified" content="2020-09-02T00:00:00+00:00"><!-- start custom article footer snippet -->

<!-- end custom article footer snippet -->
<div class="article__subscribe"><div class="subscribe"><i class="fas fa-rss"></i> <a type="application/rss+xml" href="/notes/feed.xml">Subscribe</a></div>
</div><div class="article__license"><div class="license">
    <p>This work is licensed under a <a itemprop="license" rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">Attribution-NonCommercial 4.0 International</a> license.
      <a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">
        <img alt="Attribution-NonCommercial 4.0 International" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" />
      </a>
    </p>
  </div></div></footer>
<div class="article__section-navigator clearfix"><div class="previous"><span>PREVIOUS</span><a href="/notes/2020/04/18/engl315-essay.html">The Difficulties in Interpreting Myth Between Two Worlds</a></div><div class="next"><span>NEXT</span><a href="/notes/2020/09/02/progfun2.html">Functional Program Design in Scala</a></div></div></div>

</div>

<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    $(function() {
      var $this ,$scroll;
      var $articleContent = $('.js-article-content');
      var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
      var scroll = hasSidebar ? '.js-page-main' : 'html, body';
      $scroll = $(scroll);

      $articleContent.find('.highlight').each(function() {
        $this = $(this);
        $this.attr('data-lang', $this.find('code').attr('data-lang'));
      });
      $articleContent.find('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]').each(function() {
        $this = $(this);
        $this.append($('<a class="anchor d-print-none" aria-hidden="true"></a>').html('<i class="fas fa-anchor"></i>'));
      });
      $articleContent.on('click', '.anchor', function() {
        $scroll.scrollToAnchor('#' + $(this).parent().attr('id'), 400);
      });
    });
  });
})();
</script>
</div><section class="page__comments d-print-none"></section></article><!-- start custom main bottom snippet -->

<!-- end custom main bottom snippet -->
</div>
            </div></div></div><div class="page__footer d-print-none">
<footer class="footer py-4 js-page-footer">
  <div class="main"><div itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ivy Zhou"><meta itemprop="url" content="/notes/"><meta itemprop="description" content="an uneasy soul"><div class="footer__author-links"><div class="author-links">
  <ul class="menu menu--nowrap menu--inline"><li title="Follow me on Medium.">
        <a class="button button--circle medium-button" itemprop="sameAs" href="https://medium.com/@ivyzhou" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M834.7 279.8l61.3-58.9V208H683.7L532.4 586.4 360.3 208H137.7v12.9l71.6 86.6c7 6.4 10.6 15.8 9.7 25.2V673c2.2 12.3-1.7 24.8-10.3 33.7L128 805v12.7h228.6v-12.9l-80.6-98a39.99 39.99 0 0 1-11.1-33.7V378.7l200.7 439.2h23.3l172.6-439.2v349.9c0 9.2 0 11.1-6 17.2l-62.1 60.3V819h301.2v-12.9l-59.9-58.9c-5.2-4-7.9-10.7-6.8-17.2V297a18.1 18.1 0 0 1 6.8-17.2z"></path>
</svg>
</div>
        </a>
      </li><li title="Follow me on Linkedin.">
        <a class="button button--circle linkedin-button" itemprop="sameAs" href="https://www.linkedin.com/in/zhouivy" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M260.096 155.648c0 27.307008-9.899008 50.516992-29.696 69.632-19.796992 19.115008-45.396992 28.672-76.8 28.672-30.036992 0-54.612992-9.556992-73.728-28.672-19.115008-19.115008-28.672-42.324992-28.672-69.632 0-28.672 9.556992-52.224 28.672-70.656 19.115008-18.432 44.372992-27.648 75.776-27.648 31.403008 0 56.32 9.216 74.752 27.648 18.432 18.432 28.331008 41.984 29.696 70.656 0 0 0 0 0 0m-202.752 808.96c0 0 0-632.832 0-632.832 0 0 196.608 0 196.608 0 0 0 0 632.832 0 632.832 0 0-196.608 0-196.608 0 0 0 0 0 0 0m313.344-430.08c0-58.708992-1.364992-126.292992-4.096-202.752 0 0 169.984 0 169.984 0 0 0 10.24 88.064 10.24 88.064 0 0 4.096 0 4.096 0 40.96-68.267008 105.812992-102.4 194.56-102.4 68.267008 0 123.220992 22.868992 164.864 68.608 41.643008 45.739008 62.464 113.664 62.464 203.776 0 0 0 374.784 0 374.784 0 0-196.608 0-196.608 0 0 0 0-350.208 0-350.208 0-91.476992-33.451008-137.216-100.352-137.216-47.787008 0-81.236992 24.576-100.352 73.728-4.096 8.192-6.144 24.576-6.144 49.152 0 0 0 364.544 0 364.544 0 0-198.656 0-198.656 0 0 0 0-430.08 0-430.08 0 0 0 0 0 0" />
</svg>
</div>
        </a>
      </li><li title="Follow me on Github.">
        <a class="button button--circle github-button" itemprop="sameAs" href="https://github.com/ivy-zhou" target="_blank">
          <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path class="svgpath" data-index="path_0" fill="#272636" d="M0 525.2c0 223.6 143.3 413.7 343 483.5 26.9 6.8 22.8-12.4 22.8-25.4l0-88.7c-155.3 18.2-161.5-84.6-172-101.7-21.1-36-70.8-45.2-56-62.3 35.4-18.2 71.4 4.6 113.1 66.3 30.2 44.7 89.1 37.2 119 29.7 6.5-26.9 20.5-50.9 39.7-69.6C248.8 728.2 181.7 630 181.7 513.2c0-56.6 18.7-108.7 55.3-150.7-23.3-69.3 2.2-128.5 5.6-137.3 66.5-6 135.5 47.6 140.9 51.8 37.8-10.2 80.9-15.6 129.1-15.6 48.5 0 91.8 5.6 129.8 15.9 12.9-9.8 77-55.8 138.8-50.2 3.3 8.8 28.2 66.7 6.3 135 37.1 42.1 56 94.6 56 151.4 0 117-67.5 215.3-228.8 243.7 26.9 26.6 43.6 63.4 43.6 104.2l0 128.8c0.9 10.3 0 20.5 17.2 20.5C878.1 942.4 1024 750.9 1024 525.3c0-282.9-229.3-512-512-512C229.1 13.2 0 242.3 0 525.2L0 525.2z" />
</svg>
</div>
        </a>
      </li></ul>
</div>
</div>
    </div><div class="site-info mt-2">
      <div>Â© Sentences 2020,
        Powered by <a title="Jekyll is a simple, blog-aware, static site generator." href="http://jekyllrb.com/">Jekyll</a> & <a
        title="TeXt is a super customizable Jekyll theme." href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt Theme</a>.
      </div>
    </div>
  </div>
</footer>
</div></div>
    </div><script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $body = $('body'), $window = $(window);
    var $pageRoot = $('.js-page-root'), $pageMain = $('.js-page-main');
    var activeCount = 0;
    function modal(options) {
      var $root = this, visible, onChange, hideWhenWindowScroll = false;
      var scrollTop;
      function setOptions(options) {
        var _options = options || {};
        visible = _options.initialVisible === undefined ? false : show;
        onChange = _options.onChange;
        hideWhenWindowScroll = _options.hideWhenWindowScroll;
      }
      function init() {
        setState(visible);
      }
      function setState(isShow) {
        if (isShow === visible) {
          return;
        }
        visible = isShow;
        if (visible) {
          activeCount++;
          scrollTop = $(window).scrollTop() || $pageMain.scrollTop();
          $root.addClass('modal--show');
          $pageMain.scrollTop(scrollTop);
          activeCount === 1 && ($pageRoot.addClass('show-modal'), $body.addClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.on('scroll', hide);
          $window.on('keyup', handleKeyup);
        } else {
          activeCount > 0 && activeCount--;
          $root.removeClass('modal--show');
          $window.scrollTop(scrollTop);
          activeCount === 0 && ($pageRoot.removeClass('show-modal'), $body.removeClass('of-hidden'));
          hideWhenWindowScroll && window.hasEvent('touchstart') && $window.off('scroll', hide);
          $window.off('keyup', handleKeyup);
        }
        onChange && onChange(visible);
      }
      function show() {
        setState(true);
      }
      function hide() {
        setState(false);
      }
      function handleKeyup(e) {
        // Char Code: 27  ESC
        if (e.which ===  27) {
          hide();
        }
      }
      setOptions(options);
      init();
      return {
        show: show,
        hide: hide,
        $el: $root
      };
    }
    $.fn.modal = modal;
  });
})();
</script><div class="modal modal--overflow page__search-modal d-print-none js-page-search-modal"><script>
(function () {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    // search panel
    var search = (window.search || (window.search = {}));
    var useDefaultSearchBox = window.useDefaultSearchBox === undefined ?
      true : window.useDefaultSearchBox ;

    var $searchModal = $('.js-page-search-modal');
    var $searchToggle = $('.js-search-toggle');
    var searchModal = $searchModal.modal({ onChange: handleModalChange, hideWhenWindowScroll: true });
    var modalVisible = false;
    search.searchModal = searchModal;

    var $searchBox = null;
    var $searchInput = null;
    var $searchClear = null;

    function getModalVisible() {
      return modalVisible;
    }
    search.getModalVisible = getModalVisible;

    function handleModalChange(visible) {
      modalVisible = visible;
      if (visible) {
        search.onShow && search.onShow();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].focus();
      } else {
        search.onShow && search.onHide();
        useDefaultSearchBox && $searchInput[0] && $searchInput[0].blur();
        setTimeout(function() {
          useDefaultSearchBox && ($searchInput.val(''), $searchBox.removeClass('not-empty'));
          search.clear && search.clear();
          window.pageAsideAffix && window.pageAsideAffix.refresh();
        }, 400);
      }
    }

    $searchToggle.on('click', function() {
      modalVisible ? searchModal.hide() : searchModal.show();
    });
    // Char Code: 83  S, 191 /
    $(window).on('keyup', function(e) {
      if (!modalVisible && !window.isFormElement(e.target || e.srcElement) && (e.which === 83 || e.which === 191)) {
        modalVisible || searchModal.show();
      }
    });

    if (useDefaultSearchBox) {
      $searchBox = $('.js-search-box');
      $searchInput = $searchBox.children('input');
      $searchClear = $searchBox.children('.js-icon-clear');
      search.getSearchInput = function() {
        return $searchInput.get(0);
      };
      search.getVal = function() {
        return $searchInput.val();
      };
      search.setVal = function(val) {
        $searchInput.val(val);
      };

      $searchInput.on('focus', function() {
        $(this).addClass('focus');
      });
      $searchInput.on('blur', function() {
        $(this).removeClass('focus');
      });
      $searchInput.on('input', window.throttle(function() {
        var val = $(this).val();
        if (val === '' || typeof val !== 'string') {
          search.clear && search.clear();
        } else {
          $searchBox.addClass('not-empty');
          search.onInputNotEmpty && search.onInputNotEmpty(val);
        }
      }, 400));
      $searchClear.on('click', function() {
        $searchInput.val(''); $searchBox.removeClass('not-empty');
        search.clear && search.clear();
      });
    }
  });
})();
</script><div class="search search--dark">
  <div class="main">
    <div class="search__header">Search</div>
    <div class="search-bar">
      <div class="search-box js-search-box">
        <div class="search-box__icon-search"><i class="fas fa-search"></i></div>
        <input type="text" />
        <div class="search-box__icon-clear js-icon-clear">
          <a><i class="fas fa-times"></i></a>
        </div>
      </div>
      <button class="button button--theme-dark button--pill search__cancel js-search-toggle">
        Cancel</button>
    </div>
    <div class="search-result js-search-result"></div>
  </div>
</div>
<script>var SOURCES = window.TEXT_VARIABLES.sources;
var PAHTS = window.TEXT_VARIABLES.paths;
window.Lazyload.js([SOURCES.jquery, PAHTS.search_js], function() {
  var search = (window.search || (window.search = {}));
  var searchData = window.TEXT_SEARCH_DATA || {};

  function memorize(f) {
    var cache = {};
    return function () {
      var key = Array.prototype.join.call(arguments, ',');
      if (key in cache) return cache[key];
      else return cache[key] = f.apply(this, arguments);
    };
  }

  /// search
  function searchByQuery(query) {
    var i, j, key, keys, cur, _title, result = {};
    keys = Object.keys(searchData);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      for (j = 0; j < searchData[key].length; j++) {
        cur = searchData[key][j], _title = cur.title;
        if ((result[key] === undefined || result[key] && result[key].length < 4 )
          && _title.toLowerCase().indexOf(query.toLowerCase()) >= 0) {
          if (result[key] === undefined) {
            result[key] = [];
          }
          result[key].push(cur);
        }
      }
    }
    return result;
  }

  var renderHeader = memorize(function(header) {
    return $('<p class="search-result__header">' + header + '</p>');
  });

  var renderItem = function(index, title, url) {
    return $('<li class="search-result__item" data-index="' + index + '"><a class="button" href="' + url + '">' + title + '</a></li>');
  };

  function render(data) {
    if (!data) { return null; }
    var $root = $('<ul></ul>'), i, j, key, keys, cur, itemIndex = 0;
    keys = Object.keys(data);
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      $root.append(renderHeader(key));
      for (j = 0; j < data[key].length; j++) {
        cur = data[key][j];
        $root.append(renderItem(itemIndex++, cur.title, cur.url));
      }
    }
    return $root;
  }

  // search box
  var $result = $('.js-search-result'), $resultItems;
  var lastActiveIndex, activeIndex;

  function clear() {
    $result.html(null);
    $resultItems = $('.search-result__item'); activeIndex = 0;
  }
  function onInputNotEmpty(val) {
    $result.html(render(searchByQuery(val)));
    $resultItems = $('.search-result__item'); activeIndex = 0;
    $resultItems.eq(0).addClass('active');
  }

  search.clear = clear;
  search.onInputNotEmpty = onInputNotEmpty;

  function updateResultItems() {
    lastActiveIndex >= 0 && $resultItems.eq(lastActiveIndex).removeClass('active');
    activeIndex >= 0 && $resultItems.eq(activeIndex).addClass('active');
  }

  function moveActiveIndex(direction) {
    var itemsCount = $resultItems ? $resultItems.length : 0;
    if (itemsCount > 1) {
      lastActiveIndex = activeIndex;
      if (direction === 'up') {
        activeIndex = (activeIndex - 1 + itemsCount) % itemsCount;
      } else if (direction === 'down') {
        activeIndex = (activeIndex + 1 + itemsCount) % itemsCount;
      }
      updateResultItems();
    }
  }

  // Char Code: 13  Enter, 37  â¬…, 38  â¬†, 39  âž¡, 40  â¬‡
  $(window).on('keyup', function(e) {
    var modalVisible = search.getModalVisible && search.getModalVisible();
    if (modalVisible) {
      if (e.which === 38) {
        modalVisible && moveActiveIndex('up');
      } else if (e.which === 40) {
        modalVisible && moveActiveIndex('down');
      } else if (e.which === 13) {
        modalVisible && $resultItems && activeIndex >= 0 && $resultItems.eq(activeIndex).children('a')[0].click();
      }
    }
  });

  $result.on('mouseover', '.search-result__item > a', function() {
    var itemIndex = $(this).parent().data('index');
    itemIndex >= 0 && (lastActiveIndex = activeIndex, activeIndex = itemIndex, updateResultItems());
  });
});
</script>
</div></div>


<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function scrollToAnchor(anchor, duration, callback) {
      var $root = this;
      $root.animate({ scrollTop: $(anchor).position().top }, duration, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
    $.fn.scrollToAnchor = scrollToAnchor;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function affix(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroll,
        offsetBottom = 0, scrollTarget = window, scroll = window.document, disabled = false, isOverallScroller = true,
        rootTop, rootLeft, rootHeight, scrollBottom, rootBottomTop,
        hasInit = false, curState;

      function setOptions(options) {
        var _options = options || {};
        _options.offsetBottom && (offsetBottom = _options.offsetBottom);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroll && (scroll = _options.scroll);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $scrollTarget = $(scrollTarget);
        isOverallScroller = window.isOverallScroller($scrollTarget[0]);
        $scroll = $(scroll);
      }
      function preCalc() {
        top();
        rootHeight = $root.outerHeight();
        rootTop = $root.offset().top + (isOverallScroller ? 0 :  $scrollTarget.scrollTop());
        rootLeft = $root.offset().left;
      }
      function calc(needPreCalc) {
        needPreCalc && preCalc();
        scrollBottom = $scroll.outerHeight() - offsetBottom - rootHeight;
        rootBottomTop = scrollBottom - rootTop;
      }
      function top() {
        if (curState !== 'top') {
          $root.removeClass('fixed').css({
            left: 0,
            top: 0
          });
          curState = 'top';
        }
      }
      function fixed() {
        if (curState !== 'fixed') {
          $root.addClass('fixed').css({
            left: rootLeft + 'px',
            top: 0
          });
          curState = 'fixed';
        }
      }
      function bottom() {
        if (curState !== 'bottom') {
          $root.removeClass('fixed').css({
            left: 0,
            top: rootBottomTop + 'px'
          });
          curState = 'bottom';
        }
      }
      function setState() {
        var scrollTop = $scrollTarget.scrollTop();
        if (scrollTop >= rootTop && scrollTop <= scrollBottom) {
          fixed();
        } else if (scrollTop < rootTop) {
          top();
        } else {
          bottom();
        }
      }
      function init() {
        if(!hasInit) {
          var interval, timeout;
          calc(true); setState();
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState();
          });
          $window.on('resize', function() {
            disabled || (calc(true), setState());
          });
          hasInit = true;
        }
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions,
        refresh: function() {
          calc(true, { animation: false }); setState();
        }
      };
    }
    $.fn.affix = affix;
  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function toc(options) {
      var $root = this, $window = $(window), $scrollTarget, $scroller, $tocUl = $('<ul class="toc toc--ellipsis"></ul>'), $tocLi, $headings, $activeLast, $activeCur,
        selectors = 'h1,h2,h3', container = 'body', scrollTarget = window, scroller = 'html, body', disabled = false,
        headingsPos, scrolling = false, hasRendered = false, hasInit = false;

      function setOptions(options) {
        var _options = options || {};
        _options.selectors && (selectors = _options.selectors);
        _options.container && (container = _options.container);
        _options.scrollTarget && (scrollTarget = _options.scrollTarget);
        _options.scroller && (scroller = _options.scroller);
        _options.disabled !== undefined && (disabled = _options.disabled);
        $headings = $(container).find(selectors).filter('[id]');
        $scrollTarget = $(scrollTarget);
        $scroller = $(scroller);
      }
      function calc() {
        headingsPos = [];
        $headings.each(function() {
          headingsPos.push(Math.floor($(this).position().top));
        });
      }
      function setState(element, disabled) {
        var scrollTop = $scrollTarget.scrollTop(), i;
        if (disabled || !headingsPos || headingsPos.length < 1) { return; }
        if (element) {
          $activeCur = element;
        } else {
          for (i = 0; i < headingsPos.length; i++) {
            if (scrollTop >= headingsPos[i]) {
              $activeCur = $tocLi.eq(i);
            } else {
              $activeCur || ($activeCur = $tocLi.eq(i));
              break;
            }
          }
        }
        $activeLast && $activeLast.removeClass('active');
        ($activeLast = $activeCur).addClass('active');
      }
      function render() {
        if(!hasRendered) {
          $root.append($tocUl);
          $headings.each(function() {
            var $this = $(this);
            $tocUl.append($('<li></li>').addClass('toc-' + $this.prop('tagName').toLowerCase())
              .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
          });
          $tocLi = $tocUl.children('li');
          $tocUl.on('click', 'a', function(e) {
            e.preventDefault();
            var $this = $(this);
            scrolling = true;
            setState($this.parent());
            $scroller.scrollToAnchor($this.attr('href'), 400, function() {
              scrolling = false;
            });
          });
        }
        hasRendered = true;
      }
      function init() {
        var interval, timeout;
        if(!hasInit) {
          render(); calc(); setState(null, scrolling);
          // run calc every 100 millisecond
          interval = setInterval(function() {
            calc();
          }, 100);
          timeout = setTimeout(function() {
            clearInterval(interval);
          }, 45000);
          window.pageLoad.then(function() {
            setTimeout(function() {
              clearInterval(interval);
              clearTimeout(timeout);
            }, 3000);
          });
          $scrollTarget.on('scroll', function() {
            disabled || setState(null, scrolling);
          });
          $window.on('resize', window.throttle(function() {
            if (!disabled) {
              render(); calc(); setState(null, scrolling);
            }
          }, 100));
        }
        hasInit = true;
      }

      setOptions(options);
      if (!disabled) {
        init();
      }
      $window.on('resize', window.throttle(function() {
        init();
      }, 200));
      return {
        setOptions: setOptions
      };
    }
    $.fn.toc = toc;
  });
})();
/*(function () {

})();*/
</script><script>
  /* toc must before affix, since affix need to konw toc' height. */(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  var TOC_SELECTOR = window.TEXT_VARIABLES.site.toc.selectors;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window);
    var $articleContent = $('.js-article-content');
    var $tocRoot = $('.js-toc-root'), $col2 = $('.js-col-aside');
    var toc;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');
    var hasToc = $articleContent.find(TOC_SELECTOR).length > 0;

    function disabled() {
      return $col2.css('display') === 'none' || !hasToc;
    }

    tocDisabled = disabled();

    toc = $tocRoot.toc({
      selectors: TOC_SELECTOR,
      container: $articleContent,
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      tocDisabled = disabled();
      toc && toc.setOptions({
        disabled: tocDisabled
      });
    }, 100));

  });
})();
(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    var $window = $(window), $pageFooter = $('.js-page-footer');
    var $pageAside = $('.js-page-aside');
    var affix;
    var tocDisabled = false;
    var hasSidebar = $('.js-page-root').hasClass('layout--page--sidebar');

    affix = $pageAside.affix({
      offsetBottom: $pageFooter.outerHeight(),
      scrollTarget: hasSidebar ? '.js-page-main' : null,
      scroller: hasSidebar ? '.js-page-main' : null,
      scroll: hasSidebar ? $('.js-page-main').children() : null,
      disabled: tocDisabled
    });

    $window.on('resize', window.throttle(function() {
      affix && affix.setOptions({
        disabled: tocDisabled
      });
    }, 100));

    window.pageAsideAffix = affix;
  });
})();
</script><script>
  window.Lazyload.js(['https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js', 'https://cdn.bootcss.com/Chart.js/2.7.2/Chart.bundle.min.js'], function() {
    var $canvas = null, $this = null, _ctx = null, _text = '';
    $('.language-chart').each(function(){
      $this = $(this);
      $canvas = $('<canvas></canvas>');
      _text = $this.text();
      $this.text('').append($canvas);
      _ctx = $canvas.get(0).getContext('2d');
      (_ctx && _text) && (new Chart(_ctx, JSON.parse(_text)) && $this.attr('data-processed', true));
    });
  });
</script>
<script type="text/x-mathjax-config">
	var _config = { tex2jax: {
		inlineMath: [['$','$'], ['\\(','\\)']]
	}};MathJax.Hub.Config(_config);
</script>
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  window.Lazyload.js('https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js', function() {
    mermaid.initialize({
      startOnLoad: true
    });
    mermaid.init(undefined, '.language-mermaid');
  });
</script>

    </div>
    <script>(function () {
  var $root = document.getElementsByClassName('root')[0];
  if (window.hasEvent('touchstart')) {
    $root.dataset.isTouch = true;
    document.addEventListener('touchstart', function(){}, false);
  }
})();
</script>
  </body>
</html>

